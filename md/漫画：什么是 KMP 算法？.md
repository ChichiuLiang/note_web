> 本文由 [简悦 SimpRead](http://ksria.com/simpread/) 转码， 原文地址 [baijiahao.baidu.com](https://baijiahao.baidu.com/s?id=1659735837100760934&wfr=spider&for=pc) ![](https://pics7.baidu.com/feed/0824ab18972bd40709668daa88a2d9570eb309f1.jpeg@f_auto?token=8e9cdb849f0290c6ff3e0f42aaabaeb7&s=F7D98B748553666D54D7544D0200E0FA)作者 | 小灰来源 | 程序员小灰（ID：chengxuyuanxiaohui）![](https://pics5.baidu.com/feed/5882b2b7d0a20cf43da8e94a8a220c30acaf9918.jpeg@f_auto?token=f70c8fabc893fa47cba5328def630f8d&s=11B6ED375F42604D5AF599DA020040B1)![](https://pics7.baidu.com/feed/242dd42a2834349bde30608a3cc152c836d3beb9.jpeg@f_auto?token=e144c2509c6d5aba8892dc89ad7e972f&s=45F62D771F02454D1A55B1CA000080B1)————— 第二天 —————![](https://pics3.baidu.com/feed/2e2eb9389b504fc26335137117f6a01790ef6d0a.jpeg@f_auto?token=bff6ecf226e6c88e39a246d5a772241c&s=45F6AD771543414D10FD31C80200A032)![](https://pics5.baidu.com/feed/79f0f736afc37931d9125e2019eff04343a91177.jpeg@f_auto?token=1300a7f416318fb87e66cd045ed58144&s=11B665371F436C4510FD11D802008032)![](https://pics5.baidu.com/feed/e4dde71190ef76c616b854ac643dbafcae516785.jpeg@f_auto?token=37c8be5cf25de8e520f60fa52b9d5e7c&s=55F62D7751D141CC107531C80200E032)![](https://pics5.baidu.com/feed/730e0cf3d7ca7bcbeb63d1f449222c65f724a887.jpeg@f_auto?token=b7dc6d45bc2f17cf3c2f4327ab540e8b&s=1516E1371743654950FD11D80300C032)![](https://pics0.baidu.com/feed/c2cec3fdfc039245eb1387ca71bfe3c47c1e2506.jpeg@f_auto?token=451b8bc0730ecb87e62fa15dba77d916&s=55F625775743454510D531C80300A032)![](https://pics1.baidu.com/feed/1e30e924b899a901ed5752a4e4be4d7d0308f5f0.jpeg@f_auto?token=d0b03765ab31ada21065a3bcaa9a9d1e&s=113665375F43484552FD29D80200C032)![](https://pics1.baidu.com/feed/0eb30f2442a7d9335b7fcbbf5860961571f001dc.jpeg@f_auto?token=c6cdba9e78d99497205238bc5a7b84ae&s=51763D7757424549105D29C80200E032)————————————![](https://pics4.baidu.com/feed/b999a9014c086e06645a663df1233cf20bd1cb8c.jpeg@f_auto?token=2a993d09bfe9a1ebed0135f3e4286db9&s=51F6AD774742454D12F931C802007030)![](https://pics7.baidu.com/feed/a686c9177f3e6709042dc69ec8ecd83bf8dc5550.jpeg@f_auto?token=149fe881ad70ca3b0352082088b40ae5&s=51F63D775F035C4552F931C802007030)![](https://pics4.baidu.com/feed/32fa828ba61ea8d31e3cce116e217748251f58bf.jpeg@f_auto?token=9155e56a6472e16b54903e15ff7fb669&s=0596ED375702714552F911C803005030)![](https://pics4.baidu.com/feed/0dd7912397dda1444c4114d0459c97a40cf4863e.jpeg@f_auto?token=04237b19b1c4e1a6a8115306c467d780&s=55F6AD7745D345CA12D931C803007030)前情回顾在字符串匹配算法的前两讲，我们分别介绍了暴力算法 BF 算法，利用哈希值进行比较的 RK 算法，以及尽量减少比较次数的 BM 算法，没看过的小伙伴可以点击下方链接：1. BF 算法和 RK 算法2. BM 算法如果没时间细看也没关系，就让我带着大家简单梳理一下。首先，给定 “主串” 和 “模式串” 如下：![](https://pics6.baidu.com/feed/cdbf6c81800a19d891c08c25c8d1c58da71e4684.png@f_auto?token=35bcda697a6963508052beed6de8612f)BF 算法是如何工作的？正如同它的全称 BruteForce 一样，BF 算法使用简单粗暴的方式，对主串和模式串进行逐个字符的比较：第一轮，模式串和主串的第一个等长子串比较，发现第 0 位字符一致，第 1 位字符一致，第 2 位字符不一致：![](https://pics6.baidu.com/feed/3801213fb80e7bec3253e957dc05fe3e9a506ba9.png@f_auto?token=b9e13f825c4375017779724b107ff253)![](https://pics1.baidu.com/feed/0b46f21fbe096b637cb8eb08f918c042eaf8acf3.png@f_auto?token=ae43753771b5667d40d8f0bf57d63b01)![](https://pics0.baidu.com/feed/342ac65c103853438a4805fb6038f778cb808813.png@f_auto?token=e625c0ce0d4076488b78837f5a79adf6)第二轮，模式串向后挪动一位，和主串的第二个等长子串比较，发现第 0 位字符不一致：![](https://pics3.baidu.com/feed/a8014c086e061d95898960ad8fdf4dd763d9ca0e.png@f_auto?token=fe2a077bce938e7da043ded9f2e61b8f)第三轮，模式串继续向后挪动一位，和主串的第三个等长子串比较，发现第 0 位字符不一致：![](https://pics4.baidu.com/feed/0e2442a7d933c895a41094aa243834f6830200a2.png@f_auto?token=05fd5abca8a7240493b6205ce21edb16)以此类推，一直到第 N 轮：![](https://pics3.baidu.com/feed/0824ab18972bd407347b478d83a2d9570fb30937.png@f_auto?token=ae5634de69df643096c794970e6520ac)当模式串挪动到某个合适位置，逐个字符比较，发现每一位字符都是匹配时，比较结束：![](https://pics0.baidu.com/feed/b151f8198618367aee40d660d858ccd2b21ce570.png@f_auto?token=b8a114d6ed4799ab401ad266e00fb6ec)BF 算法的缺点很明显，效率实在太低了，每一轮只能老老实实地把模式串右移一位，实际上做了很多无谓的比较。而 BM 算法解决了这一问题。它借助 “坏字符规则” 和“好后缀规则”，在每一轮比较时，让模式串尽可能多移动几位，减少无谓的比较。利用 BM 算法，上面的主串和模式串匹配只需要比较三轮：![](https://pics6.baidu.com/feed/d1a20cf431adcbef68605c6a5b8469dba3cc9f33.png@f_auto?token=88e4004eced6df1f49a8b4c470c1e932&s=39A47D32116FF0EC1AF541DE000010B0)![](https://pics7.baidu.com/feed/8644ebf81a4c510f4320a20d9772622bd52aa5f7.jpeg@f_auto?token=df0fc9454e08221994b4508dece819df&s=55F62D7719D145CE125931C803003030)![](https://pics6.baidu.com/feed/faedab64034f78f010b37e248e1a4d53b2191c5b.jpeg@f_auto?token=5927581d6c45bd59da53d5a00de93b83&s=4576257749D141CA125931C803007030)![](https://pics5.baidu.com/feed/a8ec8a13632762d04c42a26f57c74ffc503dc690.jpeg@f_auto?token=798ffa123eb9aa0c18bf8ac347361906&s=9116ED374F03744D52F911C802005030)![](https://pics0.baidu.com/feed/50da81cb39dbb6fd3d00fff2ff0fec1e962b37b8.jpeg@f_auto?token=343d03c16bbd3b12c33f5de88e1def16&s=55B62D7709D341CE12D931C803007030)KMP 算法的整体思路KMP 算法的整体思路是什么样子呢？让我们来看一组例子：![](https://pics0.baidu.com/feed/e4dde71190ef76c64c169238603dbafcae51678b.png@f_auto?token=973c5cebc081247fc7b1e7c42070fe4b)KMP 算法和 BF 算法的 “开局” 是一样的，同样是把主串和模式串的首位对齐，从左到右对逐个字符进行比较。第一轮，模式串和主串的第一个等长子串比较，发现前 5 个字符都是匹配的，第 6 个字符不匹配，是一个 “坏字符”：![](https://pics3.baidu.com/feed/962bd40735fae6cd2c36d00df898482243a70f89.png@f_auto?token=b059de744ee876c1209696ad7763dd2e)这时候，如何有效利用已匹配的前缀 “GTGTG” 呢？我们可以发现，在前缀 “GTGTG” 当中，后三个字符 “GTG” 和前三位字符 “GTG” 是相同的：![](https://pics5.baidu.com/feed/0824ab18972bd407bb7ae85e85a2d9570eb30981.png@f_auto?token=fd119f295a7a45cbca918297d8dd01dc&s=580AEC1ACD306C130AE869DA000050B2)在下一轮的比较时，只有把这两个相同的片段对齐，才有可能出现匹配。这两个字符串片段，分别叫做最长可匹配后缀子串和最长可匹配前缀子串。第二轮，我们直接把模式串向后移动两位，让两个 “GTG” 对齐，继续从刚才主串的坏字符 A 开始进行比较：![](https://pics2.baidu.com/feed/5bafa40f4bfbfbed5defc2a08ddbb030aec31f69.png@f_auto?token=91bfa7365e94e9d8dd394b227dc4aea9)显然，主串的字符 A 仍然是坏字符，这时候的匹配前缀缩短成了 GTG：![](https://pics3.baidu.com/feed/b812c8fcc3cec3fde3ecf3f2d2a493398694271c.png@f_auto?token=eb59eb8876b5b73b202575a2e91e5749)按照第一轮的思路，我们来重新确定最长可匹配后缀子串和最长可匹配前缀子串：![](https://pics3.baidu.com/feed/ae51f3deb48f8c547da29de8cc026af3e1fe7fb2.png@f_auto?token=2082eda117e5cb5d30e38e248c6fc464&s=649EEC32DDA54C130AF069DA0000C0B2)第三轮，我们再次把模式串向后移动两位，让两个 “G” 对齐，继续从刚才主串的坏字符 A 开始进行比较：![](https://pics5.baidu.com/feed/10dfa9ec8a136327d9c6d8786ba4e7ea08fac700.png@f_auto?token=ee431e4e9bed055c8b6c54675d88b8c8)以上就是 KMP 算法的整体思路：在已匹配的前缀当中寻找到最长可匹配后缀子串和最长可匹配前缀子串，在下一轮直接把两者对齐，从而实现模式串的快速移动。![](https://pics2.baidu.com/feed/29381f30e924b899a85f9183992d5a930b7bf6d8.jpeg@f_auto?token=f0f60e0481ca5f046ee0a2daa603e4bd&s=0196ED3745D171C852F110D803005030)![](https://pics7.baidu.com/feed/9e3df8dcd100baa10cd7b682bf3bfe14c9fc2ec6.jpeg@f_auto?token=7e84b850f0a4c905a15f0141a379f1c3&s=5176AD7709D045C8125131C803003030)![](https://pics5.baidu.com/feed/a8ec8a13632762d0f10678b056c74ffc513dc6b3.jpeg@f_auto?token=fe41e78333db80c77b6dd5788c95f53d&s=51F6AD7745D345C8125131C803007030)next 数组next 数组到底是个什么鬼呢？这是一个一维整型数组，数组的下标代表了 “已匹配前缀的下一个位置”，元素的值则是 “最长可匹配前缀子串的下一个位置”。或许这样的描述有些晦涩，我们来看一下图：![](https://pics3.baidu.com/feed/3bf33a87e950352a963cc089ab68bcf4b3118b80.png@f_auto?token=7a6fbc117af5a5ae5c56750ff66c77f6&s=51187C324B0752DEDF68E5CA020070B3)当模式串的第一个字符就和主串不匹配时，并不存在已匹配前缀子串，更不存在最长可匹配前缀子串。这种情况对应的 next 数组下标是 0，next[0] 的元素值也是 0。如果已匹配前缀是 G、GT、GTGTGC，并不存在最长可匹配前缀子串，所以对应的 next 数组元素值（next[1]，next[2]，next[6]）同样是 0。GTG 的最长可匹配前缀是 G，对应数组中的 next[3]，元素值是 1。以此类推，GTGT 对应 next[4]，元素值是 2。GTGTG 对应 next[5]，元素值是 3。有了 next 数组，我们就可以通过已匹配前缀的下一个位置（坏字符位置），快速寻找到最长可匹配前缀的下一个位置，然后把这两个位置对齐。比如下面的场景，我们通过坏字符下标 5，可以找到 next[5]=3，即最长可匹配前缀的下一个位置：![](https://pics0.baidu.com/feed/c75c10385343fbf24065a2e349558d8664388f53.png@f_auto?token=aa679142f8820ffb94a978c0322441bb&s=2896EC120BF858884A54B0DB0200D0B1)说完了 next 数组是什么，接下来我们再来思考一下，如何事先生成这个 next 数组呢？由于已匹配前缀数组在主串和模式串当中是相同的，所以我们仅仅依据模式串，就足以生成 next 数组。最简单的方法是从最长的前缀子串开始，把每一种可能情况都做一次比较。假设模式串的长度是 m，生成 next 数组所需的最大总比较次数是 1+2+3+4+......+m-2 次。显然，这种方法的效率非常低，如何进行优化呢？我们可以采用类似 “动态规划” 的方法。首先 next[0]和 next[1]的值肯定是 0，因为这时候不存在前缀子串；从 next[2]开始，next 数组的每一个元素都可以由上一个元素推导而来。已知 next[i] 的值，如何推导出 next[i+1] 呢？让我们来演示一下上述 next 数组的填充过程：![](https://pics0.baidu.com/feed/dbb44aed2e738bd47ff8816259a0c0d0267ff9be.png@f_auto?token=056ba3a6dfad76fc6fe813744b0d000d&s=61B03C7224D8DC212DF831D30200D0A2)如图所示，我们设置两个变量 i 和 j，其中 i 表示 “已匹配前缀的下一个位置”，也就是待填充的数组下标，j 表示 “最长可匹配前缀子串的下一个位置”，也就是待填充的数组元素值。当已匹配前缀不存在的时候，最长可匹配前缀子串当然也不存在，所以 i=0，j=0，此时 next[0] = 0。接下来，我们让已匹配前缀子串的长度加 1：![](https://pics0.baidu.com/feed/574e9258d109b3deea7020c134942b87810a4c7a.png@f_auto?token=96e02795590356696e26562f37028cea&s=65B0247224D8DC212DF831D30200D0A2)此时的已匹配前缀是 G，由于只有一个字符，同样不存在最长可匹配前缀子串，所以 i=1，j=0，next[1] = 0。接下来，我们让已匹配前缀子串的长度继续加 1：![](https://pics1.baidu.com/feed/18d8bc3eb13533fa3d1b14225ff8ba1941345b3b.png@f_auto?token=71bedf7d6152323604df249d3e901802&s=65B024726CD8DC012DF831D30200C0A2)此时的已匹配前缀是 GT，我们需要开始做判断了：由于模式串当中 pattern[j] != pattern[i-1]，即 G！=T，最长可匹配前缀子串仍然不存在。所以当 i=2 时，j 仍然是 0，next[2] = 0。![](https://pics6.baidu.com/feed/9213b07eca806538c58df25262f6e642ad34823a.png@f_auto?token=66ff4e05d1b527ed17c6eb8856ad35cc&s=65B024722CD8DC0129F821D30200C0A2)接下来，我们让已匹配前缀子串的长度继续加 1：![](https://pics6.baidu.com/feed/0dd7912397dda14419cf2d974f9c97a40df48687.png@f_auto?token=bd2dc5ea112bca120664a5fa2ec0dc67&s=65B024722CD8DC012DF821D30200D0A2)此时的已匹配前缀是 GTG，由于模式串当中 pattern[j] = pattern[i-1]，即 G=G，最长可匹配前缀子串出现了，是 G。所以当 i=3 时，j=1，next[3] = next[2]+1 = 1。![](https://pics7.baidu.com/feed/d62a6059252dd42a416b9804f5101cb3c8eab8f5.png@f_auto?token=a8dafdf7cba2c2256728d23fc91e4fbb&s=24B064320CD8DC012DF829D30200D0A2)接下来，我们让已匹配前缀子串的长度继续加 1：![](https://pics0.baidu.com/feed/95eef01f3a292df5b7229d39491a1b6635a873ee.png@f_auto?token=5b73f5c38ec150bc19e9290c9aff500a&s=E5B0247224D8DC212DF821D30200D0A2)此时的已匹配前缀是 GTGT，由于模式串当中 pattern[j] = pattern[i-1]，即 T=T，最长可匹配前缀子串又增加了一位，是 GT。所以当 i=4 时，j=2，next[4] = next[3]+1 = 2。![](https://pics7.baidu.com/feed/838ba61ea8d3fd1f9adb0b99c565621994ca5f71.png@f_auto?token=bfb57df5fc7214aea417d701519f4ae6&s=24306432CCC8FC012CF839D3020050A0)接下来，我们让已匹配前缀子串的长度继续加 1：![](https://pics3.baidu.com/feed/f3d3572c11dfa9ec22825a4a63fcb005908fc1f5.png@f_auto?token=06d8824e97421fb5373003cc8e15bba9&s=E5B0247244D8DC212DF831D30200C0A2)此时的已匹配前缀是 GTGTG，由于模式串当中 pattern[j] = pattern[i-1]，即 G=G，最长可匹配前缀子串又增加了一位，是 GTG。所以当 i=5 时，j=3，next[5] = next[4]+1 = 3。![](https://pics2.baidu.com/feed/b8389b504fc2d562af96ff4e1c3ad7e977c66cac.png@f_auto?token=f59a0ad8f188d4b6496452e3537959ad&s=25B064330CD8DC012CF831D30200D0E0)接下来，我们让已匹配前缀子串的长度继续加 1：![](https://pics1.baidu.com/feed/d31b0ef41bd5ad6e4a70537a77e07eddb7fd3c42.png@f_auto?token=238e51e6dd21e3a4708748cf888b7b57&s=E5B0247204D8DC212DF831D30200D0A2)此时的已匹配前缀是 GTGTGC，这时候需要注意了，模式串当中 pattern[j] ！= pattern[i-1]，即 T != C，这时候该怎么办呢？这时候，我们已经无法从 next[5] 的值来推导出 next[6]，而字符 C 的前面又有两段重复的子串 “GTG”。那么，我们能不能把问题转化一下？或许听起来有些绕：我们可以把计算 “GTGTGC” 最长可匹配前缀子串的问题，转化成计算 “GTGC” 最长可匹配前缀子串的问题。![](https://pics2.baidu.com/feed/d31b0ef41bd5ad6e71b5bc1d77e07eddb7fd3caf.png@f_auto?token=a5eb8a3ff2410868d925a3354604e6d2&s=00007C3281B0698254615CDF000080B2)这样的问题转化，也就相当于把变量 j 回溯到了 next[j]，也就是 j=1 的局面（i 值不变）：![](https://pics2.baidu.com/feed/8326cffc1e178a82842fcfe10f28348ba977e816.png@f_auto?token=04ab97031572a7e8b5e849b6b68c1d1e&s=6530247214D8DC212DF831D30200C0A2)回溯后，情况仍然是 pattern[j] ！= pattern[i-1]，即 T！=C。那么我们可以把问题继续进行转化：![](https://pics7.baidu.com/feed/9f510fb30f2442a7c65c44322768ea4dd013028c.png@f_auto?token=c9deaf8502988ba82fd905884a3e98c6&s=18A87C321B1F74CA5A5570DE000050B2)问题再次的转化，相当于再一次把变量 j 回溯到了 next[j]，也就是 j=0 的局面：![](https://pics7.baidu.com/feed/aec379310a55b319a2b9c214b582c520cefc17c4.png@f_auto?token=e7c363544bc513b90c75aa928a22900f&s=05B0643224D8DC252DF831D3020050A2)回溯后，情况仍然是 pattern[j] ！= pattern[i-1]，即 G！=C。j 已经不能再次回溯了，所以我们得出结论：i=6 时，j=0，next[6] = 0。![](https://pics2.baidu.com/feed/2cf5e0fe9925bc311dd72e07a6f4cab7ca13705c.png@f_auto?token=d22d1dedbb82425562917d3656ccc935&s=65B0247204D8DC2129F831D30200D0A0)以上就是 next 数组元素的推导过程。![](https://pics1.baidu.com/feed/00e93901213fb80e5e6d427acafa6828b8389494.jpeg@f_auto?token=9ea7a1c55d64de1b3853ddf55ea767c9&s=0596ED374F437D4D52F911C802005030)![](https://pics0.baidu.com/feed/94cad1c8a786c917243d7961321637c93bc75759.jpeg@f_auto?token=4b85517063e68cf7fa9263e92ebabab5&s=41F6AD7741D345C812D930C803007030)1. 对模式串预处理，生成 next 数组2. 进入主循环，遍历主串2.1. 比较主串和模式串的字符2.2. 如果发现坏字符，查询 next 数组，得到匹配前缀所对应的最长可匹配前缀子串，移动模式串到对应位置2.3. 如果当前字符匹配，继续循环KMP 算法的具体实现![](https://pics3.baidu.com/feed/8601a18b87d6277f00863e35d0135836e824fcdd.jpeg@f_auto?token=c48811393b4824a7add5d8b6cad850a9&s=15B6E5375F03614152F911C802005030)![](https://pics7.baidu.com/feed/72f082025aafa40fbb903b39514f444979f019b6.jpeg@f_auto?token=6f8b324ea74fceb352f57e93226338b5&s=51F6AD774743454D12F931C803003030)// KMP 算法主体逻辑。str 是主串，pattern 是模式串 publicstaticintkmp(String str, String pattern) {// 预处理，生成 next 数组 int[] next = getNexts(pattern);int j = 0;// 主循环，遍历主串字符 for (int i = 0; i < str.length(); i++) {while (j> 0 && str.charAt(i) != pattern.charAt(j)) {// 遇到坏字符时，查询 next 数组并改变模式串的起点 j = next[j];}if (str.charAt(i) == pattern.charAt(j)) { j++;}if (j == pattern.length()) {// 匹配成功，返回下标 return i - pattern.length() + 1;}}return-1;}// 生成 Next 数组 privatestaticint[] getNexts(String pattern) {int[] next = newint[pattern.length()];int j = 0;for (int i=2; i<pattern.length(); i++) {while (j != 0 && pattern.charAt(j) != pattern.charAt(i-1)) {// 从 next[i+1] 的求解回溯到 next[j] j = next[j];}if (pattern.charAt(j) == pattern.charAt(i-1)) { j++;}next[i] = j;}return next;}publicstaticvoidmain(String[] args) {String str = "ATGTGAGCTGGTGTGTGCFAA";String pattern = "GTGTGCF";int index = kmp(str, pattern);System.out.println("首次出现位置：" + index);}![](https://pics4.baidu.com/feed/267f9e2f0708283888a8d7ad45b2ee074d08f190.jpeg@f_auto?token=13dd106550faec859424021f9f5c474b&s=45B62D7745D345C8125131C803003030)![](https://pics4.baidu.com/feed/5243fbf2b21193132ae3442b93134bd190238dbf.jpeg@f_auto?token=a85ab733185b4fce89c3310e10904427&s=01F6ED374F036C4552F911C80200C030)![](https://pics3.baidu.com/feed/a6efce1b9d16fdfa4c049e5c4ca4cb5295ee7bce.jpeg@f_auto?token=58a0313afbf243e5858311f1edf5191c&s=0597E53755527DCC52F911D803005030)![](https://pics0.baidu.com/feed/f3d3572c11dfa9ec60b0614594fbb005908fc1fc.jpeg@f_auto?token=1baf1c7b1ea76d9514ffaaea18b1e37c&s=0496E5374DD27CC850F910D803005030)![](https://pics1.baidu.com/feed/7aec54e736d12f2e917580dab7e99264843568cd.jpeg@f_auto?token=2759366560f5aca45bed71fe1316b496&s=8596ED3747517DCC52D911C803005030)![](https://pics3.baidu.com/feed/738b4710b912c8fc89c983750428d543d6882105.jpeg@f_auto?token=a36dc363996ec6a37a638a13b6b9b139&s=45F6257745D245C812D131C803007030)【End】阿里大牛：华先胜、丁险峰直播分享！今晚 7 点，阿里巴巴集团副总裁华先胜——《人工智能：是风、是云，还是雨？》面向开发者详解视觉智能技术规模化落地的挑战；面向企业详述如何通过核心 AI 技术、产品化 及平台化实现客户价值并构建壁垒？举报 / 反馈