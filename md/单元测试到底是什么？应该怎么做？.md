> 本文由 [简悦 SimpRead](http://ksria.com/simpread/) 转码， 原文地址 [www.zhihu.com](https://www.zhihu.com/question/28729261) ![](https://pica.zhimg.com/v2-f3e3a9dcfb2d2a875914f9b139983cc2_l.jpg?source=1def8aca)腾讯技术工程​

分享下一篇鹅厂程序猿对单元测试的理解以及如何做单元测试。

在我们谈到单元测试，大都清楚是[测试函数](https://www.zhihu.com/search?q=%E6%B5%8B%E8%AF%95%E5%87%BD%E6%95%B0&search_source=Entity&hybrid_search_source=Entity&hybrid_search_extra=%7B%22sourceType%22%3A%22answer%22%2C%22sourceId%22%3A1058317111%7D)符合预期，国外很多大公司都将单测执行的很好，国内成功的案例则相对有限。在本文中，笔者将在腾讯新闻项目中亲身经历单测从无到有的实践过程梳理为可读可参考的经验分享出来。在实践的过程我发现，单测可以推动产品质量转为优秀，推动实行它的过程更需要对它有真实的认识以及一套[方法论](https://www.zhihu.com/search?q=%E6%96%B9%E6%B3%95%E8%AE%BA&search_source=Entity&hybrid_search_source=Entity&hybrid_search_extra=%7B%22sourceType%22%3A%22answer%22%2C%22sourceId%22%3A1058317111%7D)。 **为单元测试 “正名”**

我曾经认为，单元测试面向的是一个函数。任何走出一个函数的测试，都不是单元测试。 其实，对 “单元” 的定义取决于自己。如果你正在使用[函数式编程](https://www.zhihu.com/search?q=%E5%87%BD%E6%95%B0%E5%BC%8F%E7%BC%96%E7%A8%8B&search_source=Entity&hybrid_search_source=Entity&hybrid_search_extra=%7B%22sourceType%22%3A%22answer%22%2C%22sourceId%22%3A1058317111%7D)，一个单元最有可能指的是一个函数。你的单元测试将使用不同的参数调用这个函数，并断言它返回了期待的结果；在[面向对象语言](https://www.zhihu.com/search?q=%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E8%AF%AD%E8%A8%80&search_source=Entity&hybrid_search_source=Entity&hybrid_search_extra=%7B%22sourceType%22%3A%22answer%22%2C%22sourceId%22%3A1058317111%7D)里，下至一个方法，上至一个类都可以是一个单元（从一个单一的方法到一整个的类都可以是一个单元）。意图很重要（“意图” 二字是本文中第一次提到，它很重要） 我们有单元测试、增量测试、集成测试、回归测试、[冒烟测试](https://www.zhihu.com/search?q=%E5%86%92%E7%83%9F%E6%B5%8B%E8%AF%95&search_source=Entity&hybrid_search_source=Entity&hybrid_search_extra=%7B%22sourceType%22%3A%22answer%22%2C%22sourceId%22%3A1058317111%7D)等等，名字非常多。谷歌看到这种 “[百家争鸣](https://www.zhihu.com/search?q=%E7%99%BE%E5%AE%B6%E4%BA%89%E9%B8%A3&search_source=Entity&hybrid_search_source=Entity&hybrid_search_extra=%7B%22sourceType%22%3A%22answer%22%2C%22sourceId%22%3A1058317111%7D)” 的现象，创立了自己的命名方式，只分为**小型测试**、**中型测试**和**大型测试**。

*   小型测试，针对单个函数的测试，关注其内部逻辑，mock 所有需要的服务。小型测试带来优秀的代码质量、良好的异常处理、优雅的[错误报告](https://www.zhihu.com/search?q=%E9%94%99%E8%AF%AF%E6%8A%A5%E5%91%8A&search_source=Entity&hybrid_search_source=Entity&hybrid_search_extra=%7B%22sourceType%22%3A%22answer%22%2C%22sourceId%22%3A1058317111%7D)
*   中型测试，验证两个或多个制定的模块应用之间的交互
*   大型测试，也被称为 “[系统测试](https://www.zhihu.com/search?q=%E7%B3%BB%E7%BB%9F%E6%B5%8B%E8%AF%95&search_source=Entity&hybrid_search_source=Entity&hybrid_search_extra=%7B%22sourceType%22%3A%22answer%22%2C%22sourceId%22%3A1058317111%7D)” 或 “端到端测试”。大型测试在一个较高层次上运行，验证系统作为一个整体是如何工作的。

![](https://pic1.zhimg.com/v2-d59083a4a9e4cd791b68b6a46d97feff_r.jpg?source=1def8aca)![](https://picx.zhimg.com/v2-9009b5a38656fe3cfe9016d51ce659de_r.jpg?source=1def8aca)

**结论**：我们的单元测试，既可以针对一个函数写 case，也可以按照函数的调用关系串起来写 case。 **金字塔模型**

在[金字塔模型](https://www.zhihu.com/search?q=%E9%87%91%E5%AD%97%E5%A1%94%E6%A8%A1%E5%9E%8B&search_source=Entity&hybrid_search_source=Entity&hybrid_search_extra=%7B%22sourceType%22%3A%22answer%22%2C%22sourceId%22%3A1058317111%7D)之前，流行的是冰淇淋模型。包含了大量的手工测试、端到端的自动化测试及少量的单元测试。造成的后果是，随着产品壮大，手工回归测试时间越来越长，质量很难把控；自动化 case 频频失败，每一个失败对应着一个长长的[函数调用](https://www.zhihu.com/search?q=%E5%87%BD%E6%95%B0%E8%B0%83%E7%94%A8&search_source=Entity&hybrid_search_source=Entity&hybrid_search_extra=%7B%22sourceType%22%3A%22answer%22%2C%22sourceId%22%3A1058317111%7D)，到底哪里出了问题？单元测试少的可怜，基本没作用。

![](https://pic1.zhimg.com/v2-c1339f6d6e6e890a3fed4ba0a86d08f2_r.jpg?source=1def8aca)

Mike Cohn 在他的着作《Succeeding with Agile》一书中提出了 **“测试金字塔”** 这个概念。这个比喻非常形象，它让你一眼就知道测试是需要分层的。它还告诉你每一层需要写多少测试。 测试金字塔本身是一条很好的经验法则，我们最好记住 Cohn 在金字塔模型中提到的两件事：

*   编写不同粒度的测试
*   层次越高，你写的测试应该越少

![](https://picx.zhimg.com/v2-eb5ca7a07359b22c754ed8e024b01a1f_r.jpg?source=1def8aca)

同时，我们对金字塔的理解绝不能止步于此，要进一步理解： 我把金字塔模型理解为——**冰激凌融化了**。就是指，最顶部的 “[手工测试](https://www.zhihu.com/search?q=%E6%89%8B%E5%B7%A5%E6%B5%8B%E8%AF%95&search_source=Entity&hybrid_search_source=Entity&hybrid_search_extra=%7B%22sourceType%22%3A%22answer%22%2C%22sourceId%22%3A1058317111%7D)” 理论上全部要自动化，向下融化，优先全部考虑融化成单元测试，单元测试覆盖不了的 放在中间层（分层测试），再覆盖不了的才会放到 [UI 层](https://www.zhihu.com/search?q=UI%E5%B1%82&search_source=Entity&hybrid_search_source=Entity&hybrid_search_extra=%7B%22sourceType%22%3A%22answer%22%2C%22sourceId%22%3A1058317111%7D)。因此，UI 层的 case，能没有就不要有，跑的慢还不稳定。按照乔帮主的说法，我不分单元测试还是分层测试，统一都叫[自动化测试](https://www.zhihu.com/search?q=%E8%87%AA%E5%8A%A8%E5%8C%96%E6%B5%8B%E8%AF%95&search_source=Entity&hybrid_search_source=Entity&hybrid_search_extra=%7B%22sourceType%22%3A%22answer%22%2C%22sourceId%22%3A1058317111%7D)，那就应该把所有的自动化 case 看做一个整体，case 不要冗余，单元测试能覆盖，就要把这个 case 从分层或 ui 中去掉。 越是底层的测试，牵扯到相关内容越少，而高层测试则涉及面更广。比如单元测试，它的关注点只有一个单元，而没有其它任何东西。所以，只要一个单元写好了，测试就是可以通过的；而[集成测试](https://www.zhihu.com/search?q=%E9%9B%86%E6%88%90%E6%B5%8B%E8%AF%95&search_source=Entity&hybrid_search_source=Entity&hybrid_search_extra=%7B%22sourceType%22%3A%22answer%22%2C%22sourceId%22%3A1058317111%7D)则要把好几个单元组装到一起才能测试，测试通过的前提条件是，所有这些单元都写好了，这个周期就明显比单元测试要长；系统测试则要把整个系统的各个模块都连在一起，各种数据都准备好，才可能通过。 另外，因为涉及到的模块过多，任何一个模块做了调整，都有可能破坏高层测试，所以，高层测试通常是相对比较脆弱的，在实际的工作中，有些高层测试会牵扯到外部系统，这样一来，复杂度又在不断地提升。 **为什么做单测**

这个问题我们规避不掉。新闻是这次研发模式改革的主力军之一，所以自上而下的推动让这个问题不那么棘手：做了就是做了。不做，却又有那么多的理由：（搜集到的吐槽真实声音）

*   _单元测试浪费了太多的时间_
*   _单元测试仅仅是证明这些代码做了什么_
*   _我是很棒的程序员，我是不是可以不进行单元测试？_
*   _后面的集成测试将会抓住所有的 bug_
*   _单元测试的成本效率不高我把测试都写了，那么测试人员做什么呢？_
*   _公司请我来是写代码，而不是写测试_
*   _测试代码的正确性，并不是我的工作_

我觉得我们总监指导的很到位：改革，一是工作方式的改革，更难的是思想上的改革。 **单元测试的意义**

新闻的总监 dot 老师是至始至终推进单测的好领导，他讲述了[螺丝钉](https://www.zhihu.com/search?q=%E8%9E%BA%E4%B8%9D%E9%92%89&search_source=Entity&hybrid_search_source=Entity&hybrid_search_extra=%7B%22sourceType%22%3A%22answer%22%2C%22sourceId%22%3A1058317111%7D)与飞机的故事：[干货 | 测试扁平化之必备神器：好的单元测试](https://link.zhihu.com/?target=https%3A//mp.weixin.qq.com/s%3F__biz%3DMzA5MTAzNjU1OQ%3D%3D%26mid%3D2454779818%26idx%3D1%26sn%3D0c91a9b637a7a7ecf1c2d30e94d521b1%26chksm%3D87a6d94ab0d1505c90c8f3f495402aa76f50fe42df3c4660e775670be8833c10c377956cccae%26mpshare%3D1%26scene%3D21%26srcid%3D%26rd2werd%3D1%23wechat_redirect)

![](https://pic1.zhimg.com/v2-4e379681579f8331b50d24abe56b2963_r.jpg?source=1def8aca)

*   单元测试对我们的产品质量是非常重要的。
*   单元测试是所有测试中最底层的一类测试，是第一个环节，也是最重要的一个环节，是唯一一次有保证能够[代码覆盖率](https://www.zhihu.com/search?q=%E4%BB%A3%E7%A0%81%E8%A6%86%E7%9B%96%E7%8E%87&search_source=Entity&hybrid_search_source=Entity&hybrid_search_extra=%7B%22sourceType%22%3A%22answer%22%2C%22sourceId%22%3A1058317111%7D)达到 100% 的测试，是整个[软件测试](https://www.zhihu.com/search?q=%E8%BD%AF%E4%BB%B6%E6%B5%8B%E8%AF%95&search_source=Entity&hybrid_search_source=Entity&hybrid_search_extra=%7B%22sourceType%22%3A%22answer%22%2C%22sourceId%22%3A1058317111%7D)过程的基础和前提，单元测试防止了开发的后期因 bug 过多而失控，单元测试的性价比是最好的。
*   据统计，大约有 80% 的错误是在[软件设计](https://www.zhihu.com/search?q=%E8%BD%AF%E4%BB%B6%E8%AE%BE%E8%AE%A1&search_source=Entity&hybrid_search_source=Entity&hybrid_search_extra=%7B%22sourceType%22%3A%22answer%22%2C%22sourceId%22%3A1058317111%7D)阶段引入的，并且修正一个软件错误所需的费用将随着软件生命期的进展而上升。错误发现的越晚，修复它的费用就越高，而且呈指数增长的趋势。作为编码人员，也是单元测试的主要执行者，是唯一能够做到生产出无缺陷程序这一点的人，其他任何人都无法做到这一点
*   代码规范、优化，可测试性的代码
*   放心重构
*   自动化执行 three-thousand times

下面这张图，来自微软的统计数据：bug 在单元测试阶段被发现，平均耗时 3.25 小时，如果漏到系统测试阶段，要花费 11.5 小时。

![](https://picx.zhimg.com/v2-7fa19055f44338bc9d6806a66dbee392_r.jpg?source=1def8aca)

下面这张图，旨在说明两个问题：85% 的缺陷都在代码设计阶段产生，而发现 bug 的阶段越靠后，耗费成本就越高，指数级别的增高。所以，在早期的单元测试就能发现 bug，省时省力，一劳永逸，何乐而不为呢

![](https://picx.zhimg.com/v2-f86dccc193f8c61610005c7bc37e1b6f_r.jpg?source=1def8aca)

**单元测试特别耗时？**

**不能一刀切，不能只盯着单测阶段的耗时**。 我采访了新闻[客户端](https://www.zhihu.com/search?q=%E5%AE%A2%E6%88%B7%E7%AB%AF&search_source=Entity&hybrid_search_source=Entity&hybrid_search_extra=%7B%22sourceType%22%3A%22answer%22%2C%22sourceId%22%3A1058317111%7D)、后台的开发，首先肯定的是，单测会增加开发量、增加开发时长。

![](https://pic1.zhimg.com/v2-c981a1555cddb02d5af9ab24e653ba63_r.jpg?source=1def8aca)

在《单元测试的艺术》这本书提到一个案例：找了开发能力相近的两个团队，同时开发相近的需求。进行单测的团队在编码阶段时长增长了一倍，从 7 天到 14 天，但是，这个团队在集成测试阶段的表现非常顺畅，bug 量小，定位 bug 迅速等。最终的效果，整体交付时间和[缺陷数](https://www.zhihu.com/search?q=%E7%BC%BA%E9%99%B7%E6%95%B0&search_source=Entity&hybrid_search_source=Entity&hybrid_search_extra=%7B%22sourceType%22%3A%22answer%22%2C%22sourceId%22%3A1058317111%7D)，均是单测团队最少。

![](https://picx.zhimg.com/v2-b1d07e36140a15fba78ad44531e64e2f_r.jpg?source=1def8aca)

单测，[存在即合理](https://www.zhihu.com/search?q=%E5%AD%98%E5%9C%A8%E5%8D%B3%E5%90%88%E7%90%86&search_source=Entity&hybrid_search_source=Entity&hybrid_search_extra=%7B%22sourceType%22%3A%22answer%22%2C%22sourceId%22%3A1058317111%7D)。一方面，需要把单测放在整个迭代周期来观测其效果；一方面，写单测也是技术活，**写得好的同学**，时间少代码质量高（也即，不是说写了单测，就能写好单测） **谁来写单测呢？**

*   开发同学写单测
*   测试同学具有写单测的能力。重点在于开发脚手架、分层测试 / 端到端测试

**增量还是存量**

*   单测 case 针对[增量代码](https://www.zhihu.com/search?q=%E5%A2%9E%E9%87%8F%E4%BB%A3%E7%A0%81&search_source=Entity&hybrid_search_source=Entity&hybrid_search_extra=%7B%22sourceType%22%3A%22answer%22%2C%22sourceId%22%3A1058317111%7D)
*   当存量代码出现大规模重构，后者质量暴露出极大风险时，都是推动补全单测的好时机

**单元测试的阶段**

一. 广义的单元测试，我们指这三部分的有机组合：

*   code review
*   静态代码扫描
*   单元[测试用例](https://www.zhihu.com/search?q=%E6%B5%8B%E8%AF%95%E7%94%A8%E4%BE%8B&search_source=Entity&hybrid_search_source=Entity&hybrid_search_extra=%7B%22sourceType%22%3A%22answer%22%2C%22sourceId%22%3A1058317111%7D)编写

二. 结合新闻的实践，我把单测成长的过程分为 4 个目标，分别为：

*   会写，全员可写
*   写的好，同时关注可测性问题，试点解决
*   识别可测性问题，熟练使用重构方法进行重构；识别代码[架构设计](https://www.zhihu.com/search?q=%E6%9E%B6%E6%9E%84%E8%AE%BE%E8%AE%A1&search_source=Entity&hybrid_search_source=Entity&hybrid_search_extra=%7B%22sourceType%22%3A%22answer%22%2C%22sourceId%22%3A1058317111%7D)问题；case 与[业务代码](https://www.zhihu.com/search?q=%E4%B8%9A%E5%8A%A1%E4%BB%A3%E7%A0%81&search_source=Entity&hybrid_search_source=Entity&hybrid_search_extra=%7B%22sourceType%22%3A%22answer%22%2C%22sourceId%22%3A1058317111%7D)同步编写
*   TDD。但这个目标是期望，不能作为必须实现的目标。

![](https://picx.zhimg.com/v2-24302ebdcc5f5d0f93011c870aa1e28a_r.jpg?source=1def8aca)

截至发稿当天，新闻处于第三阶段，即，每个迭代均能产出高质量的 case，人数覆盖和需求覆盖均较高；关注重点在于可测性，时刻注重重构。 **单元测试的指标**

还挺尴尬的，不太有直接的指标去衡量单测的效果。我们也经常被问到，“怎么证明你们新闻单测的作用呀？”

*   bug 类指标（间接指标）：连续迭代的 bug 总数趋势、迭代内新建 bug 的趋势、千行 bug 率
*   单测的需求覆盖度（50% 以上），参与人员覆盖度（80% 以上）
*   单测 case 总数趋势，代码行增量趋势
*   增量代码的行覆盖率（接入层 80%，客户端 30%）
*   单函数圈复杂度（低于 40），[单函数](https://www.zhihu.com/search?q=%E5%8D%95%E5%87%BD%E6%95%B0&search_source=Entity&hybrid_search_source=Entity&hybrid_search_extra=%7B%22sourceType%22%3A%22answer%22%2C%22sourceId%22%3A1058317111%7D)代码行数（低于 80），扫描告警数

在迭代需求持续高吞吐量的前提下，以新闻 iOS 的数据为例：

![](https://picx.zhimg.com/50/v2-a4c8ce2f3859ba5567baf82ff51d1111_720w.jpg?source=1def8aca)![](https://pica.zhimg.com/v2-dfd2177ad21eb0f772a72aa0b8a73c9e_r.jpg?source=1def8aca)![](https://pic1.zhimg.com/v2-838adbb4702598a72497c9c95319feaa_r.jpg?source=1def8aca)![](https://picx.zhimg.com/v2-47d1bf4cc1ee8e5e26b2c4448c538f87_r.jpg?source=1def8aca)

**go 单元测试框架选型**

基本选型：testify + gomonkey 附加：httptest + sqlmock

![](https://picx.zhimg.com/50/v2-eaa8e47c105ea95a1f5455a4c16d03c5_720w.jpg?source=1def8aca)![](https://picx.zhimg.com/v2-b3368a67cb9926b8f902ac65df8e42ed_r.jpg?source=1def8aca)

**前提**

*   测试文件，以_test.go 结尾，与被测文件放于相同目录
*   测试函数，函数名以 Test 开头，并且随后的第一个字符必须为大写字母或下划线，如：TestParseReq_CorrectNum_TableDriven
*   测试函数，参数为 t *testing.T；对于 bench 测试，参数为 b *testing.B
*   运行命令行，我的文章有深入讲解：[go test 命令行](https://link.zhihu.com/?target=http%3A//km.oa.com/group/11880/articles/show/383434)

**testify 常规用法**

[https://github.com/stretchr/testify](https://link.zhihu.com/?target=https%3A//github.com/stretchr/testify) testify 基于 gotesting 编写，所以语法上、执行命令行与 go test 完全兼容

*   支持大量高效的 api，比如：

assert.Equal：常规对比，是把两者分别换成 []byte 去严格比对 assert.Nil：判断对象为 nil 时，有时对 err 判空时也用 assert.Error：判断 err 的具体类型和内容 assert.JSONEq：这个比较有用，对比 map 时；或者对比 [struct](https://www.zhihu.com/search?q=struct&search_source=Entity&hybrid_search_source=Entity&hybrid_search_extra=%7B%22sourceType%22%3A%22answer%22%2C%22sourceId%22%3A1058317111%7D) 的时候，也会先转为 map，在用这个 api 去做对比，如下面这个例子，我封装了建议的方法去将 struct 转换为 string(json)：

![](https://pica.zhimg.com/v2-b04908725c9ab2c0e0dda7d9c6b51e4e_r.jpg?source=1def8aca)![](https://pica.zhimg.com/v2-9ebc392868f4e3eda32e383191df7e2e_r.jpg?source=1def8aca)

*   支持 suite，用例集管理
*   运行时，可以指定用例集执行

![](https://pic1.zhimg.com/v2-4e2ce2d8b028536893d45574cf03c9c1_r.jpg?source=1def8aca)

*   自带 mock 工具，但只支持接口方法的 mock，而且用法相对复杂
*   table-driven

![](https://pica.zhimg.com/v2-56c4a379933bca57e271537d3caaac7e_r.jpg?source=1def8aca)

**gomonkey 用法（加粗字体表示常用）**

[https://github.com/agiledragon/gomonkey](https://link.zhihu.com/?target=https%3A//github.com/agiledragon/gomonkey) [https://studygolang.com/articles/15034](https://link.zhihu.com/?target=https%3A//studygolang.com/articles/15034)

*   **支持为一个函数打一个桩**
*   **支持为一个成员方法打一个桩**
*   支持为一个[全局变量](https://www.zhihu.com/search?q=%E5%85%A8%E5%B1%80%E5%8F%98%E9%87%8F&search_source=Entity&hybrid_search_source=Entity&hybrid_search_extra=%7B%22sourceType%22%3A%22answer%22%2C%22sourceId%22%3A1058317111%7D)打一个桩
*   支持为一个函数变量打一个桩
*   **支持为一个函数打一个特定的桩序列**
*   **支持为一个成员方法打一个特定的桩序列**
*   支持为一个函数变量打一个特定的桩序列
*   table-driven 的方式定义一系列 stub

注意，对[内联函数](https://www.zhihu.com/search?q=%E5%86%85%E8%81%94%E5%87%BD%E6%95%B0&search_source=Entity&hybrid_search_source=Entity&hybrid_search_extra=%7B%22sourceType%22%3A%22answer%22%2C%22sourceId%22%3A1058317111%7D)的 Stub，go test 命令行一定要加上参数才可生效。见官方文档。所以，我的命令行默认加上 - gcflags=all=-l 就行了。

![](https://picx.zhimg.com/v2-c19df6ac68ccd7f3665b8e25d7dbdc38_r.jpg?source=1def8aca)

完整文章见：

[从头到脚说单测——谈有效的单元测试](https://link.zhihu.com/?target=https%3A//mp.weixin.qq.com/s/okmWMOeBm7cCIZ1zzFr4KQ)

 ![](https://pic1.zhimg.com/v2-8d5919087cfd8d1abc569d15905516c5_l.jpg?source=1def8aca) coolhappy

介绍怎么做单元测试的书很多，这里主要解答：**为什么**单元测试。

客观来说，单元测试和使用[版本控制系统](https://www.zhihu.com/search?q=%E7%89%88%E6%9C%AC%E6%8E%A7%E5%88%B6%E7%B3%BB%E7%BB%9F&search_source=Entity&hybrid_search_source=Entity&hybrid_search_extra=%7B%22sourceType%22%3A%22answer%22%2C%22sourceId%22%3A163637881%7D)（GIT,SVN）是一样重要的。

为什么单元测试如此重要，但你却感受不到。

首先要知道，**代码的终极目标有两个，第一个是实现需求，第二个是提高代码质量和可维护性。**  
单元测试是为了提高代码质量和可维护性，是实现代码的第二个目标的一种方法。  
（注：代码的可维护性是指增加一个新功能，或改变现有功能的成本，成本越低，可维护性即越高。）

—————————————————场景 1：Hello World—————————————————  
任何一个伟大的程序员都是从最简单的代码开始写起的，假设你的第一个程序是 Hello World，任何一个语言实现这个程序都只需要不到 5 行代码。

**这个程序需要单元测试吗？**，我们看看这个程序是否实现了软件的两个目标：  
1. 需求很简单，输出 Hello World，这个程序完全满足需求。  
2. 只有 5 行代码的 “软件” 无论是代码质量，还是可维护性，都相当高，你想要把 Hello 改成 Hi 真的很轻松。  
既然我们已经实现了代码的目标，要不要使用单元测试是无所谓的，同样这么简单的代码也没人会使用 GIT 或 SVN。  
代码量：5 行

—————————————————场景 2：简单计算器—————————————————  
接下来你写了一个相对更复杂的程序，一个简单计算器。  
这个程序实现了数字的加减乘除，整个程序共写了大概 50 行代码。

**这个程序需要单元测试吗？**  
1. 需求是对数字进行[加减乘除](https://www.zhihu.com/search?q=%E5%8A%A0%E5%87%8F%E4%B9%98%E9%99%A4&search_source=Entity&hybrid_search_source=Entity&hybrid_search_extra=%7B%22sourceType%22%3A%22answer%22%2C%22sourceId%22%3A163637881%7D)，这个程序满足了需求。  
2. 你的代码风格很好（你已经了解到代码风格很重要），你使用了[缩进](https://www.zhihu.com/search?q=%E7%BC%A9%E8%BF%9B&search_source=Entity&hybrid_search_source=Entity&hybrid_search_extra=%7B%22sourceType%22%3A%22answer%22%2C%22sourceId%22%3A163637881%7D)，良好的变量命名，逻辑也清晰，代码的质量和可维护性仍然相当高，如果你想增加一个 “求 x 的平方” 功能，你轻而易举就可以做到。  
这个时候让你去写单元测试，你仍然会觉得那纯粹是浪费时间。  
代码量：50 行

—————————————————场景 3：[图书管理系统](https://www.zhihu.com/search?q=%E5%9B%BE%E4%B9%A6%E7%AE%A1%E7%90%86%E7%B3%BB%E7%BB%9F&search_source=Entity&hybrid_search_source=Entity&hybrid_search_extra=%7B%22sourceType%22%3A%22answer%22%2C%22sourceId%22%3A163637881%7D)————————————————  
你想要做一个真正的实用系统，给学校开发一个图书管理系统。  
你相信这个系统的代码量比起计算器会很多（可能会有 1000 行）。  
你从书上看到有这样一些方法可以简化你的开发工作：  
1. **工具库**（类似你家里的[工具箱](https://www.zhihu.com/search?q=%E5%B7%A5%E5%85%B7%E7%AE%B1&search_source=Entity&hybrid_search_source=Entity&hybrid_search_extra=%7B%22sourceType%22%3A%22answer%22%2C%22sourceId%22%3A163637881%7D)），使用工具库带来的好处是非常明显的，假如你要实现 “返回一个[数字数组](https://www.zhihu.com/search?q=%E6%95%B0%E5%AD%97%E6%95%B0%E7%BB%84&search_source=Entity&hybrid_search_source=Entity&hybrid_search_extra=%7B%22sourceType%22%3A%22answer%22%2C%22sourceId%22%3A163637881%7D)中的最大值”，你只需要使用某个工具库的 Max() 函数，只需要 1 行代码，而不是 10 行代码自己实现。  
2.**MVC 框架**，虽然比起工具库更复杂，需要花更多时间学习，但 [MVC 框架](https://www.zhihu.com/search?q=MVC%E6%A1%86%E6%9E%B6&search_source=Entity&hybrid_search_source=Entity&hybrid_search_extra=%7B%22sourceType%22%3A%22answer%22%2C%22sourceId%22%3A163637881%7D)带来的好处也非常明显，轻而易举调用数据库（Model），实现简单的 UI 界面（View），实现了类似 “书名为空的书不允许添加到[数据库](https://www.zhihu.com/search?q=%E6%95%B0%E6%8D%AE%E5%BA%93&search_source=Entity&hybrid_search_source=Entity&hybrid_search_extra=%7B%22sourceType%22%3A%22answer%22%2C%22sourceId%22%3A163637881%7D)” 的一些逻辑（Controller）。  
你最终很好的实现了这个系统，基于 MVC 模型，你的代码被很好的分割成了很多小的独立的模块：4 个 Controller，2 个 Model，4 个 View。并且在工具库的帮助下，[代码量](https://www.zhihu.com/search?q=%E4%BB%A3%E7%A0%81%E9%87%8F&search_source=Entity&hybrid_search_source=Entity&hybrid_search_extra=%7B%22sourceType%22%3A%22answer%22%2C%22sourceId%22%3A163637881%7D)得到了缩减，每个模块大概只有 50 行代码（等同于一个简单计算器的代码量）。

**这个系统需要单元测试吗？**  
1. 你实现了对图书的添加、删除、修改、借阅，你很好的满足了需求（校长表扬了你）。  
2. 得益于框架与库的使用，你的代码被很好的[模块化](https://www.zhihu.com/search?q=%E6%A8%A1%E5%9D%97%E5%8C%96&search_source=Entity&hybrid_search_source=Entity&hybrid_search_extra=%7B%22sourceType%22%3A%22answer%22%2C%22sourceId%22%3A163637881%7D)了，每个模块都像一个 “[简单计算器](https://www.zhihu.com/search?q=%E7%AE%80%E5%8D%95%E8%AE%A1%E7%AE%97%E5%99%A8&search_source=Entity&hybrid_search_source=Entity&hybrid_search_extra=%7B%22sourceType%22%3A%22answer%22%2C%22sourceId%22%3A163637881%7D)” 那样简单，增加新功能，或修改现有功能似乎也没有什么大麻烦，虽然会出现一些小 bug，但很快就修复了，代码质量和可维护性都比较高。  
既然你又实现了代码的目标——“完成需求，高代码质量和可维护性”，那好像也没 “单元测试” 什么事，毕竟写它要浪费额外的功夫，而且也没感觉到有多少好处。  
代码量：500 行

————————————————场景 3：大型[库存管理系统](https://www.zhihu.com/search?q=%E5%BA%93%E5%AD%98%E7%AE%A1%E7%90%86%E7%B3%BB%E7%BB%9F&search_source=Entity&hybrid_search_source=Entity&hybrid_search_extra=%7B%22sourceType%22%3A%22answer%22%2C%22sourceId%22%3A163637881%7D)———————————————  
你被一家 IT 公司雇佣了，你通过了面试，进入了一个即将开启的项目——为一家大的电商公司做一个库存管理系统。  
项目初期一切都很顺利，技术上和你做过的图书管理系统差不多。  
首先你了解了客户的需求，然后根据他们的需求，使用你已经掌握的 MVC 框架和一些库，实现了他们的需求。你写了 30 个 Controller， 50 个 Model，50 个 View，每个模块的代码都达到了大概 150 行，总代码达到了惊人的 20000 行！  
你觉得自己很了不起，能 hold 住这么多代码，这完全是得益于你的高智商，以及工作努力。客户很满意，老板也很满意，你的自我感觉也很不错。

并且你发现了比单元测试更好的东西，**面向对象编程**（OOP），或**[函数式编程](https://www.zhihu.com/search?q=%E5%87%BD%E6%95%B0%E5%BC%8F%E7%BC%96%E7%A8%8B&search_source=Entity&hybrid_search_source=Entity&hybrid_search_extra=%7B%22sourceType%22%3A%22answer%22%2C%22sourceId%22%3A163637881%7D)**（FP），无论是哪一种，你发现你可以把一个模块里的 150 行堆砌在一起的代码再提取成 1 个对象的 15 种方法，或者 15 个独立的函数（具体怎么提取，你得看相关的书籍），OOP 或 FP 像 MVC 模型一样，成功的把你的代码分割成了更小的组成部分，每个方法或函数里代码都只有 10 行左右，你几乎回到了 “Hello World” 时代。

**你需要单元测试吗？（你能保证你的系统没有 BUG 吗？）**

这个[复杂系统](https://www.zhihu.com/search?q=%E5%A4%8D%E6%9D%82%E7%B3%BB%E7%BB%9F&search_source=Entity&hybrid_search_source=Entity&hybrid_search_extra=%7B%22sourceType%22%3A%22answer%22%2C%22sourceId%22%3A163637881%7D)是由 1950 个[函数](https://www.zhihu.com/search?q=%E5%87%BD%E6%95%B0&search_source=Entity&hybrid_search_source=Entity&hybrid_search_extra=%7B%22sourceType%22%3A%22answer%22%2C%22sourceId%22%3A163637881%7D)和方法组成，如果想要确定系统整体没有 BUG，就等同于确定组成这个系统的 1950 个函数和方法没有 BUG。  
而单元测试就是做这个事情的，显而易见，如果你写了[单元测试](https://www.zhihu.com/search?q=%E5%8D%95%E5%85%83%E6%B5%8B%E8%AF%95&search_source=Entity&hybrid_search_source=Entity&hybrid_search_extra=%7B%22sourceType%22%3A%22answer%22%2C%22sourceId%22%3A163637881%7D)，并且每个函数都通过了，你就可以骄傲的说：这个系统没有 BUG!（当然这是代码的角度，而非功能和产品的角度）

-——————————————————-—**结论**—————————————————————

**虽然，从绝对的角度说，单元测试很重要，但是，从相对的角度来讲，小的代码量，简单固定的需求，个人开发，[一锤子买卖](https://www.zhihu.com/search?q=%E4%B8%80%E9%94%A4%E5%AD%90%E4%B9%B0%E5%8D%96&search_source=Entity&hybrid_search_source=Entity&hybrid_search_extra=%7B%22sourceType%22%3A%22answer%22%2C%22sourceId%22%3A163637881%7D)等等都会让单元测试显得不那么重要，并且你一直开发的很舒服，这就是为什么有的人感受不到单元测试的重要性（这种情况下的确也许不用写单元测试）。记住，单元测试的威力更多不是体现在新代码的编写上，而是对已有代码的更改。**但程序员的智慧是有限的，系统的复杂度却是无限的，随着更大挑战的到来，当系统的复杂度超过了你的逻辑，记忆能力，你必须依靠别的工具来帮助你减少问题。（宇宙中最复杂的系统就是宇宙本身了，假设宇宙是上帝写的系统，上帝可能太聪明了，所以可能没写单元测试，虽然你也是你[软件](https://www.zhihu.com/search?q=%E8%BD%AF%E4%BB%B6&search_source=Entity&hybrid_search_source=Entity&hybrid_search_extra=%7B%22sourceType%22%3A%22answer%22%2C%22sourceId%22%3A163637881%7D)系统的创建者，但你不是上帝）

如果你现在在做一个较大的项目，这个项目的需求很多，所以你一直在开发，你遇到了这样的痛苦状况：1. 客户总能在使用中找出 BUG，2. 每次代码的改动，都会导致一些意想不到的 BUG 出现。这个时候，单元测试可以挽救你。

-——————————————————-—**问答**—————————————————————  
**即使我看了单元测试的书，也一头雾水，不知道怎么测试[我的系统](https://www.zhihu.com/search?q=%E6%88%91%E7%9A%84%E7%B3%BB%E7%BB%9F&search_source=Entity&hybrid_search_source=Entity&hybrid_search_extra=%7B%22sourceType%22%3A%22answer%22%2C%22sourceId%22%3A163637881%7D)：**

这种情况可能是你代码本身导致的，首先你要写具有 **“可测性”** 的代码，这意味着你不能写[面向过程](https://www.zhihu.com/search?q=%E9%9D%A2%E5%90%91%E8%BF%87%E7%A8%8B&search_source=Entity&hybrid_search_source=Entity&hybrid_search_extra=%7B%22sourceType%22%3A%22answer%22%2C%22sourceId%22%3A163637881%7D)的，流水式的，几百行逻辑堆一起的代码（也叫意大利面代码，就像一盘意大利面一样搅在一起的代码。），你要学一些模块化技巧，**面向对象**和**函数式编程**理念，还有很多其它具体方法，比如能用本地变量，就不要用[全局变量](https://www.zhihu.com/search?q=%E5%85%A8%E5%B1%80%E5%8F%98%E9%87%8F&search_source=Entity&hybrid_search_source=Entity&hybrid_search_extra=%7B%22sourceType%22%3A%22answer%22%2C%22sourceId%22%3A163637881%7D)等等，让你的代码具有可测性，这些知识的学习应该放在单元测试之前。

**单元测试代码比功能代码也多，这样成本很高：**

事实上单元测试代码都是异常简单的一些 “断言” 代码，断言就是判断一个函数或对象的一个方法所产生的结果是否等于你期望的那个结果，这样的代码看起来很多，但事实上书写的成本很低。（因为我们开发软件的大部分时间用在了思考上，而不是敲代码上，单元测试的代码逻辑很简单，不需要太多思考）。

**不是有 UI 界面吗，点来点去就可以测试了啊：**

你完全可以这样做，直到你觉得这么枯燥的事情真的应该交给电脑去做，或者功能越来越多，你只点击你认为影响到的功能，但总会有那些你认为不会影响到的功能也被影响了，你又懒得全部点一遍，单元测试是在你每次改完代码后自动执行，获得反馈只要几秒，并且会把所有功能跑一遍。

**我们项目有专职测试人员啊，写单元测试的必要还大吗：**

单元测试是检查代码粒度的 bug（一般是以函数和对象的方法为粒度），你可以依赖测试人员，但如果你不想在修改自己一个月前写的代码时自己把自己弄到吐血（或者把别人弄到吐血），最好在当初就写好测试代码，这个工作的责任完全属于程序员。外国已经有很多资深程序员论证了，不论你的单元测试代码质量有多高，覆盖面有多全，单单是你去做这一件事，就可以很大程度的提高你的功能代码的质量，以及大幅减少 BUG 的存在。![](https://pic1.zhimg.com/v2-4976c67916ead84ecd6e430aa678ad09_l.jpg?source=1def8aca)黑马测试​

我是 Java 程序员出身，后来因为工作原因转到到了测试开发岗位。测试开发工作很多年后，现在我在黑马程序员软件测试学科担任课程研究员兼黑马测试开发课程主讲老师。针对题主的两个问题，我还有些发言权，特来回复下：

> 1、什么是单元测试  
> 2、该怎么做单元测试

* * *

**一、什么是单元测试？**
--------------

单元测试（unit testing），是指对软件中的最小可测试单元进行检查和验证。至于 “单元” 的大小或范围，并没有一个明确的标准，“单元”可以是一个函数、方法、类、功能模块或者子系统

**单元测试通常和白盒测试联系到一起**，如果单从概念上来讲两者是有区别的，不过我们通常所说的 “单元测试” 和“白盒测试”都认为是和代码有关系的，所以在某些语境下也通常认为这两者是同一个东西。还有一种理解方式，**单元测试和白盒测试就是对开发人员所编写的代码进行测试**。

> 提示：概念这个东西大概理解是什么意思即可~

如果想了解单元测试与其他测试的区别，可狠戳下方链接：

[单元测试，集成测试，系统测试的区别是什么？](https://www.zhihu.com/question/53143398/answer/3257797000)![](https://picx.zhimg.com/50/v2-555c1ca786e091ff55e2161003976656_720w.jpg?source=1def8aca)

**二、单元测试谁来做？**
--------------

> 想一想：前面我们介绍了，单元测试简单理解就是对开发人员所编写的代码进行测试，既然和代码相关我们第一感觉那应该是 “开发人员来做”；再一看单元测试包含“测试” 两个字，那么 “测试人员来做” 也应该是合理的吧。

单元测试一般是有开发人员或测试人员来做。谁来做并没有一个绝对的标准，要根据公司的实际情况来决定。接下来我们分析一下开发人员或测试人员做单元测试的优缺点：

### 开发人员做单元测试：

*   优点：开发人员对代码最熟悉，而且开发人员编程技能相对比较强，所以开发人员自己写单元测试效率上和覆盖率上都比较高
*   缺点：开发人员平时写业务代码就要花费很多时间，有时候确实没有时间写单元测试；而且大部分开发人员没有太好的测试思想，单元测试可能只是写个最简单的用例就完了；自己写的代码自己测，往往都是不靠谱！

### 测试人员做单元测试：

*   优点：测试人员有比较系统的测试思想，可以更好地保证用例的覆盖。而且通过写单测测试能更好地了解具体代码结构、流程，对于后续的业务测试也非常有利。
*   缺点：测试人员的编程技能相对比较弱，如果不同编程是无法开展单元测试的。并且测试人员对代码没有开发人员熟悉，效率会比较低。

![](https://pica.zhimg.com/v2-1e100e75eaa516248ae2b1134aa62d34_r.jpg?source=1def8aca)

**三、单元测试怎么做？**
--------------

单元测试的实现方式包括：人工静态检查、动态执行跟踪

*   人工静态检查：就是通常所说的 “代码走读”，主要是保证代码逻辑的正确性
*   动态执行跟踪：就是把程序代码运行起来，检查实际的运行结果和预期结果是否一致

### **人工静态检查**

人工静态检查包含的主要内容：

*   检查算法的逻辑正确性
*   模块接口的正确性检查
*   输入参数有没有作正确性检查
*   调用其他方法接口的正确性
*   异常错误处理
*   保证表达式、SQL 语句的正确性
*   检查常量或全局变量使用的正确性
*   程序风格的一致性、规范性
*   检查代码注释是否完整

### **动态执行跟踪**

动态执行跟踪需要编写测试脚本调用业务代码进行测试，为了更好的管理维护测试脚本，一般会采用单元测试框架来管理，不同的语言有不同的单元测试框架：

*   Java：JUnit、TestNG
*   Python：UintTest、pyTest

单元测试的一个重要的衡量标准就是[代码覆盖率](https://www.zhihu.com/search?q=%E4%BB%A3%E7%A0%81%E8%A6%86%E7%9B%96%E7%8E%87&search_source=Entity&hybrid_search_source=Entity&hybrid_search_extra=%7B%22sourceType%22%3A%22answer%22%2C%22sourceId%22%3A2009501611%7D)，尽量做到代码的全覆盖。常见单元测试覆盖标准：

*   [语句覆盖](https://www.zhihu.com/search?q=%E8%AF%AD%E5%8F%A5%E8%A6%86%E7%9B%96&search_source=Entity&hybrid_search_source=Entity&hybrid_search_extra=%7B%22sourceType%22%3A%22answer%22%2C%22sourceId%22%3A2009501611%7D)
*   分支覆盖
*   [条件覆盖](https://www.zhihu.com/search?q=%E6%9D%A1%E4%BB%B6%E8%A6%86%E7%9B%96&search_source=Entity&hybrid_search_source=Entity&hybrid_search_extra=%7B%22sourceType%22%3A%22answer%22%2C%22sourceId%22%3A2009501611%7D)
*   分支 - 条件覆盖
*   条件组合覆盖
*   路径覆盖

入门示例：针对开发人员编写的实现计算操作的方法进行单元测试

```
# 开发人员编写的业务代码
class CalUtil:
    """计算器"""

    @staticmethod
    def add(x, y):
        """加法"""
        return x + y

    @staticmethod
    def sub(x, y):
        """减法"""
        return x - y

    @staticmethod
    def mul(x, y):
        """乘法"""
        return x * y

    @staticmethod
    def div(x, y):
        """除法"""
        return x / y


```

```
# 单元测试脚本
import unittest
from test_ut.cal import CalUtil

class TestCal(unittest.TestCase):
    def test_add_01(self):
        # 测试数据
        x = 1
        y = 2
        expect = 3

        # 调用被测方法
        result = CalUtil.add(x, y)
        print(f"result={result}")

        # 断言
        self.assertEqual(expect, result)

    def test_add_02(self):
        # 测试数据
        x = 1
        y = -1
        expect = 0

        # 调用被测方法
        result = CalUtil.add(x, y)
        print(f"result={result}")

        # 断言
        self.assertEqual(expect, result)

    # ...

```

**单元测试基本等同于白盒测试**，所以若想对于单元测试有更深入的了解，可以看下黑马测试《[白黑测试用例设计](https://www.zhihu.com/search?q=%E7%99%BD%E9%BB%91%E6%B5%8B%E8%AF%95%E7%94%A8%E4%BE%8B%E8%AE%BE%E8%AE%A1&search_source=Entity&hybrid_search_source=Entity&hybrid_search_extra=%7B%22sourceType%22%3A%22answer%22%2C%22sourceId%22%3A2009501611%7D)》这个视频教程，请狠狠点击下方链接 ( 有[百度网盘](https://www.zhihu.com/search?q=%E7%99%BE%E5%BA%A6%E7%BD%91%E7%9B%98&search_source=Entity&hybrid_search_source=Entity&hybrid_search_extra=%7B%22sourceType%22%3A%22answer%22%2C%22sourceId%22%3A2009501611%7D)和 b 站视频链接 )：

[《白盒测试用例设计》，免费下载 - 黑马程序员技术交流社区](https://link.zhihu.com/?target=http%3A//bbs.itheima.com/thread-494591-1-1.html%3Fzhihuxhw)

**敲字不易，如果此文章对你有帮助的话，点个赞收个藏，给作者一个鼓励。也方便你下次能够[快速查找](https://www.zhihu.com/search?q=%E5%BF%AB%E9%80%9F%E6%9F%A5%E6%89%BE&search_source=Entity&hybrid_search_source=Entity&hybrid_search_extra=%7B%22sourceType%22%3A%22answer%22%2C%22sourceId%22%3A2009501611%7D)。**

**---------------------------------------------------------------------------------------------------**

**最后，为方便大家自学软件测试，特意给大家准备了一份 13G 的超实用干货学习资源，涉及所有测试知识点。**

还包括软件学习路线图，黑马 50 多天的上课视频、16 个突击实战项目，80 余个软件测试用软件，37 份测试文档，70 个软件测试相关问题，40 篇测试经验级文章，上千份测试真题分享，还有 2020-2023 历年软件测试面试宝典，还有软件测试求职的各类精选简历，希望对大家有所帮助….. **狠戳下方链接：**

[2023 软件测试学习路线图, 内附视频教程 + 自学路线 + 工具 + 面试篇 - 黑马程序员技术交流社区](https://link.zhihu.com/?target=http%3A//bbs.itheima.com/thread-405757-1-1.html%3Fzhihuxhw)

**如果对你有帮助的话，点个赞收个藏，给作者一个鼓励。也方便你下次能够快速找到。**

* * *

**黑马精华[知乎](https://www.zhihu.com/search?q=%E7%9F%A5%E4%B9%8E&search_source=Entity&hybrid_search_source=Entity&hybrid_search_extra=%7B%22sourceType%22%3A%22answer%22%2C%22sourceId%22%3A3281447224%7D)文章推荐：**
-------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------

### **一、测试前景类**

[软件测试有前景吗？](https://www.zhihu.com/question/57345611/answer/1533729709)

[软件测试行业到底有没有前景和出路？](https://www.zhihu.com/question/317754170/answer/1569957027)

[软件测试工程师的工资有多高？](https://www.zhihu.com/question/359606043/answer/1581863304)

[软件测试这个职业能干多久?](https://www.zhihu.com/question/350089274/answer/1566170490)

[软件测试真的干到 35 就干不动了吗？](https://www.zhihu.com/question/61117238/answer/1540761285)

[自动化测试的发展前景怎么样？相比于开发，测试的技术含量是否偏低？测试人员提升自身竞争力的速度是否没开发快？](https://www.zhihu.com/question/20253813/answer/1605703580)

[软件测试的岗位会越来越少吗？](https://www.zhihu.com/question/312309010/answer/1619000950)

[测试开发是什么？为什么现在那么多公司都要招聘测试开发？](https://www.zhihu.com/question/61776013/answer/1641290287)

[国内的软件测试那么不受待见吗？](https://www.zhihu.com/question/32039241/answer/1929289331)

[软件测试有哪些前景？](https://www.zhihu.com/question/20050816/answer/2200717221)

[软件测试真的看不到前途吗？](https://www.zhihu.com/question/454997801/answer/2324487359)

[27 岁了，目前从事软件测试，听一些大神说测试前途是 IT 里最差的，是这样吗？](https://www.zhihu.com/question/46294465/answer/2460143784)

[很多程序员都说 35 岁职业危机，那么为什么做开发的 35 岁程序员不转做测试呢？](https://www.zhihu.com/question/366571406/answer/2473355079)

[最近十年，软件测试领域有什么重要进展？](https://www.zhihu.com/question/49535296/answer/2480562370)

[如果纯做业务测试的话，在测试行业有出路吗？](https://www.zhihu.com/question/419996933/answer/2577648665)

[既然测试也要求写代码，那干脆让开发兼任测试不就好了吗？](https://www.zhihu.com/question/539134546/answer/2744078681)

[为什么今年软件测试这么难找工作?](https://www.zhihu.com/question/536534719/answer/2788142148)

[软件测试车载方向怎么样？](https://www.zhihu.com/question/486590381/answer/3076181544)

[从长远来看，软件测试这个行业怎么样？](https://www.zhihu.com/question/358849870/answer/3084060294)

[软件测试，培训 3 个月真能月薪过万吗？](https://www.zhihu.com/question/464378008/answer/3146915936)

### 二、测试择业类

[二十五岁零基础转行做软件测试怎么样？](https://www.zhihu.com/question/26096931/answer/1466836178)

[本人女，想转行做软件测试，没有任何经验，也没有基础，现在已经毕业两年了，25 岁，现在转行来得及吗？](https://www.zhihu.com/question/50776270/answer/1492383614)

[女生学软件测试，容易吗，这个工作会不会压力很大？](https://www.zhihu.com/question/383071919/answer/1543754884)

[软件测试员比软件开发员要求低些吗？](https://www.zhihu.com/question/20156659/answer/1478497867)

[软件测试的魅力何在？您为什么选择测试一行而不做开发？](https://www.zhihu.com/question/20269633/answer/1474604912)

[软件测试的工资高还是开发者工资高？](https://www.zhihu.com/question/33405392/answer/1649870187)

[软件开发和软件测试两个岗位应该选哪个？](https://www.zhihu.com/question/67605808/answer/1671998253)

[为什么软件测试相比软件开发薪酬待遇差别那么大？](https://www.zhihu.com/question/56939189/answer/1850310934)

[软件测试适合女孩子吗？](https://www.zhihu.com/question/448348305/answer/2072588684)

[男 27，想转行互联网，是学习软件测试好，还是前端编程？](https://www.zhihu.com/question/408642335/answer/2080910630)

[软件测试工程师的一天工作内容是什么？](https://www.zhihu.com/question/266949343/answer/1748646649)

[关于职业规划，自动化测试和软件开发我该如何选择？](https://www.zhihu.com/question/268026469/answer/2176945851)

[想做软件测试，不知道自己是否合适？](https://www.zhihu.com/question/22332066/answer/2319420217)

[软件测试适合女孩子吗，平时加班多吗？](https://www.zhihu.com/question/391784878/answer/1808108092)

[想做软件测试，不知道自己是否合适？](https://www.zhihu.com/question/22332066/answer/2319420217)

[软件测试和软件开发哪个比较好？](https://www.zhihu.com/question/54178888/answer/1617568139)

[开发，运维，测试，实施哪个好？](https://www.zhihu.com/question/333838044/answer/2616325903)

[想转行软件测试，听说是 IT 界最轻松的行业，不知道可不可行？](https://www.zhihu.com/question/475107372/answer/2871053183)

[前端开发，测试，后端，该如何选择？](https://www.zhihu.com/question/313891095/answer/3044398559)

[软件测试真的很简单吗？](https://www.zhihu.com/question/517560640/answer/3288659741)

### 三、测试入门类

[作为一名软件测试人员，有哪些网站是你应该多多关注的，哪些书籍是你必须要看的？](https://www.zhihu.com/question/34450022/answer/1452024287)

[作为一名软件测试工程师，需要具备哪些能力？](https://www.zhihu.com/question/19752175/answer/1453207343)

[软件测试人员怎么快速让自己牛逼起来？大概要多久才能很牛逼？](https://www.zhihu.com/question/27344791/answer/1462142979)

[大四应届毕业生，想自学软件测试，要学到什么程度才能找到工作？](https://www.zhihu.com/question/264794090/answer/1521634764)

[如何系统、高效地学习入门软件测试，并能找到软件测试的工作？](https://www.zhihu.com/question/29255430/answer/1532426126)

[零基础想转行做软件测试，可以吗？](https://www.zhihu.com/question/39673618/answer/1554794486)

[软件测试需要学什么？](https://www.zhihu.com/question/312686899/answer/1561502395)

[想要成为一个优秀的软件测试人员，应该学些什么？](https://www.zhihu.com/question/20254092/answer/1551917922)

[零基础如何通过学习进入软件测试行业？](https://www.zhihu.com/question/22875187/answer/1567721326)

[在校生想成为软件测试工程师自学需要学什么？](https://www.zhihu.com/question/21652695/answer/1568490399)

[新人如何入门和学习软件测试？](https://www.zhihu.com/question/22230085/answer/1594809785)

[自学软件测试怎么学？](https://www.zhihu.com/question/20352581/answer/1594933637)

[怎样做好软件测试](https://www.zhihu.com/question/19798371/answer/1545112971)

[测试分为什么，白盒，黑盒，单元，集成测试？](https://www.zhihu.com/question/24345678/answer/1611528501)

[在国外，资深的软件测试人员大多是手动测试，他们厉害之处在于测试用例的设计，但在国内，很多测试人员都把自动化测试当成很厉害的资本，为什么？](https://www.zhihu.com/question/19721142/answer/1633490943)

[作为软件测试的前辈你能不能给我点建议？](https://www.zhihu.com/question/392607753/answer/1684261852)

[我想问一下，软件测试要学会什么才能拿 6k 以上的工资？](https://www.zhihu.com/question/417429478/answer/1700675063)

[学习软件测试有哪些推荐的网站，希望各位知友帮助？](https://www.zhihu.com/question/45987531/answer/1906320959)

[28 岁女失业，想从零学习软件测试，还来得及吗？](https://www.zhihu.com/question/43570118/answer/1907281206)

[大四女生，软件测试岗，对测试也不太了解，编码能力也不行。不知道未来该如何规划，如何系统性学习测试呢？](https://www.zhihu.com/question/314916265/answer/1918529378)

[没有软件测试经验的计算机毕业生如何准备面试测试工程师这一职位？](https://www.zhihu.com/question/26779409/answer/1927775843)

[一个无经验的应届生，可以做软件测试吗？](https://www.zhihu.com/question/277633071/answer/1971110118)

[完全未接触过软件测试的人，培训两个月就可上岗，这现实吗？](https://www.zhihu.com/question/26535291/answer/2008701149)

[测试开发是代表懂测试的开发还是懂开发的测试？](https://www.zhihu.com/question/355306885/answer/2009409350)

[今年 30 了，做了 5 年的软件测试，只会功能测试的怎么办？](https://www.zhihu.com/question/378579065/answer/2125853221)

[学习软件测试需要掌握哪些知识点呢？](https://www.zhihu.com/question/55580287/answer/2126140092)

[28 岁转行软件测试真的很难吗？](https://www.zhihu.com/question/56959087/answer/2347975350)

[我想问一下，软件测试要学会些什么才能拿 6K 以上的工资？](https://www.zhihu.com/question/417429478/answer/1700675063)

[一个菜鸟怎样做好功能测试？](https://www.zhihu.com/question/49877910/answer/1597914370)

[零基础转行学习软件测试如何入手？](https://www.zhihu.com/question/43533845/answer/1606411665)

[25 岁什么都不会进入软件测试晚吗？](https://www.zhihu.com/question/385370327/answer/1716678558)

[零基础可以通过什么方式进入到软件测试行业？](https://www.zhihu.com/question/22875187/answer/1567721326)

[测试分为什么，白盒，黑盒，单元，集成测试？](https://www.zhihu.com/question/24345678/answer/1611528501)

[想学习软件测试，求推荐看什么书或者教程？](https://www.zhihu.com/question/41619186/answer/1641793037)

[Python 和 Java 哪个更适合做自动化测试？](https://www.zhihu.com/question/264353399/answer/2453360401)

[初级测试工程师（能找到工作的水平就行）1、学多久 2、学什么？](https://www.zhihu.com/question/328019885/answer/2461556074)

[测试工程师到底是干啥的？测试工程师转开发有多大希望？](https://www.zhihu.com/question/30744528/answer/2469629648)

[学软件测试需要准备啥？](https://www.zhihu.com/question/421992883/answer/2483957867)

[国外知名 IT 企业是如何做测试的？](https://www.zhihu.com/question/22947392/answer/2541383626)

[测试好多都是性能小白，虽学了些性能知识，但在实际工作做开展性能测试，都很茫然，求指导，应该怎么处理？](https://www.zhihu.com/question/63975448/answer/2610023184)

[游戏测试是一个怎样的行业？](https://www.zhihu.com/question/26221508/answer/2617863892)

[为什么互联网公司不开除测试，转而让大众来测，找到一个 bug 给 100 元？](https://www.zhihu.com/question/27236089/answer/2684507111)

[Fiddler 到底能做什么?](https://www.zhihu.com/question/55617707/answer/2690009021)

[Android 手机自动化测试工具有哪几种？](https://www.zhihu.com/question/19716849/answer/2930155323)

[有哪些比较好的测试用例管理工具？](https://www.zhihu.com/question/26898212/answer/2940946212)

[测试用例是怎么写的？](https://www.zhihu.com/question/272193009/answer/2962583197)

[接口自动化测试要做什么？](https://www.zhihu.com/question/384727359/answer/3051556678)

[关于基本功能测试用例，到底是传统的表格（Excel）形式好还是思维导图（Xmind、MindManager 等）模式好？](https://www.zhihu.com/question/27023220/answer/3054114209)

[软件测试人员的基本功包括哪些？](https://www.zhihu.com/question/19824394/answer/3116508245)

[29 岁转行软件测试靠谱吗？](https://www.zhihu.com/question/448950161/answer/3157604027)

[新人学习 selenium 哪些资源比较有帮助?](https://www.zhihu.com/question/62375263/answer/3164990663)

[常见的软件测试用例设计方法有哪些呢？](https://www.zhihu.com/question/20227936/answer/3170101858)

[你们如何实现前端项目的自动化测试？](https://www.zhihu.com/question/37977930/answer/3198226504)

[软件测试的流程？](https://www.zhihu.com/question/42023056)

[单元测试，集成测试，系统测试的区别是什么？](https://www.zhihu.com/question/53143398/answer/3257797000)

[测试人力不足时，测试技术层面有什么方法可以提高测试效率？](https://www.zhihu.com/question/55930045/answer/3281447224)

[为什么要写测试用例，测试用例写给谁看？](https://www.zhihu.com/question/265165586/answer/3282874577)

### 四、咨询培训类

[软件测试培训靠谱吗？](https://www.zhihu.com/question/31755542/answer/1511612189)

[这么多的软件测试培训机构，哪个好？](https://www.zhihu.com/question/21471129/answer/1501002082)

[传智播客 (黑马程序员) 培训软件测试怎么样？](https://www.zhihu.com/question/311390807/answer/2110937460)

[转行学软件测试，培训机构收费 1.5W-2W 不等，学习时间 2 个月左右，这种靠谱吗？](https://www.zhihu.com/question/341545460/answer/2319735225)

[转行软件测试，报培训班 3 个月出来就是高薪工作，靠谱吗？](https://www.zhihu.com/question/289107467/answer/2312091425)

[软件测试到底要不要报培训班？](https://www.zhihu.com/question/46734424/answer/2470129665)

[软件测试培训班有推荐的吗，多少钱？](https://www.zhihu.com/question/518438908/answer/2588988369)

[软件测试自学还是报班好？](https://www.zhihu.com/question/379008484/answer/3118793973)

[软件测试培训出来真的很难找到工作嘛？](https://www.zhihu.com/question/450535206/answer/3220387428)

### 五、测试求职类

[怎么的技能可以让软件测试工程师获得高薪？](https://www.zhihu.com/question/20210162/answer/1460533301)

[面试软件测试工作，如何回答: 为什么要从事软件测试行业？你觉得你会什么？](https://www.zhihu.com/question/27284577/answer/1490808367)

[如何去面试软件测试工程师？](https://www.zhihu.com/question/28981475/answer/1501615849)

[好的软件测试人员简历是什么样子的？](https://www.zhihu.com/question/22709265/answer/1587753632)

[四年手动软件测试，裸辞后找不到工作怎么办？](https://www.zhihu.com/question/56831599/answer/1520268900)

[明天去面试软件测试，给我些建议，或者面试题预测？](https://www.zhihu.com/question/31998301/answer/1714488045)

[测试工程师面试题，你都遇到过哪些呢？](https://www.zhihu.com/question/58155715/answer/1910135509)

[最近在找实习。面试软件测试时，面试最想听到的答案是什么？](https://www.zhihu.com/question/23653109/answer/1970893562)

[面试题：软件测试，如何测微信的朋友圈？](https://www.zhihu.com/question/61307545/answer/2318401417)

[软件测试的真实面试题有吗？](https://www.zhihu.com/question/416143278/answer/2322230320)

[应届生找软件测试的工作应该怎么准备？](https://www.zhihu.com/question/21289768/answer/1922748219)

[软件测试，如何工资过万？](https://www.zhihu.com/question/32254638/answer/1838781246)

[离职一个月了，也面了很多公司，但都没有 offer, 软件测试工作不难找，为啥我就那么难找？](https://www.zhihu.com/question/58326643/answer/1770302085)

[软件测试简历项目经验怎么写，没有项目经验？](https://www.zhihu.com/question/297929745/answer/2367785915)

[20 岁零基础转行软件测试领域，求知友分享自学干货和面试经验？](https://www.zhihu.com/question/28665725/answer/2490993036)

[自学软件测试，学到什么程度可以出去找工作啊？](https://www.zhihu.com/question/459064840/answer/2583973877)

[30 岁软件测试，目前已失业 4 个月，迷茫不知该怎么办？](https://www.zhihu.com/question/445607492/answer/2589106385)

[从培训机构出来的软件测试工程师，公司会介意吗？](https://www.zhihu.com/question/265325674/answer/3030766223)

[软件测试面试怎样介绍自己的测试项目？会问到什么程度？](https://www.zhihu.com/question/344637461/answer/3045967443)

[实在没货，简历（软件测试）咋写？有 HR 帮喵喵么？](https://www.zhihu.com/question/53406712/answer/3139529098)

[大家面试测试工程师一般问什么问题？](https://www.zhihu.com/question/58694183/answer/3218928330)

[软件测试面试会问哪些问题？](https://www.zhihu.com/question/586812790/answer/3279645537)

### 六、技术分享类

[如何编写测试用例？](https://www.zhihu.com/question/51558124/answer/1494934653)

[手机软件的测试主要有哪些方面去测试，性能测试用什么去测试好？](https://www.zhihu.com/question/21588174/answer/1514892788)

[如何做好 app 的测试工作?](https://www.zhihu.com/question/22195880/answer/1530837450)

[软件测试完后，还有 BUG，是测试人员的问题吗？](https://www.zhihu.com/question/26463640/answer/1571901839)

[如何写出高效的软件测试用例？](https://www.zhihu.com/question/39865629/answer/1639536795)

[做接口测试的流程一般是怎么样的？](https://www.zhihu.com/question/57553476/answer/1660621101)

[软件测试人员能用 python 做哪些事情？](https://www.zhihu.com/question/31593520/answer/1677327903)

[软件测试的环境部署怎么做？](https://www.zhihu.com/question/51992962/answer/1700357765)

[如何做接口测试呢？接口测试有哪些工具](https://www.zhihu.com/question/45504975/answer/1968942767)

[求推荐几款 http 接口自动化测试工具？](https://www.zhihu.com/question/32223087/answer/1974065215)

[单元测试到底是什么？应该怎么做？](https://www.zhihu.com/question/28729261/answer/2009501611)

[想学习 LoadRunner，有没有好的资源（书籍、视频或网站）？](https://www.zhihu.com/question/25082930/answer/2070783141)

[怎么看待 QA（软件测试）漏测 bug？](https://www.zhihu.com/question/39389917/answer/2215057188)

[测试工程师都是怎么写测试用例的？](https://www.zhihu.com/question/339206144/answer/2322810917)

[国内哪些移动 app 开发团队做了自动化测试？能否介绍一下具体的实现方案？](https://www.zhihu.com/question/20188761/answer/2317740272)

[如何保证接口测试的覆盖率？](https://www.zhihu.com/question/39703248/answer/2418666827)

[android 下的 app 性能测试应主要针对那些方面，如何开展?](https://www.zhihu.com/question/21493125/answer/2609768173)

[如何做一份精致的性能测试报告？](https://www.zhihu.com/question/24248575/answer/2634381185)

[如何进行前端自动化测试？](https://www.zhihu.com/question/29922082/answer/2642635207)

[对一个即将上线的网站，如何做一个较完整的 Web 应用 / 网站测试？](https://www.zhihu.com/question/20463394/answer/2666451672)

[有什么比较好的类似 BugFree 的 bug 管理工具？](https://www.zhihu.com/question/24412418/answer/2802175010)

[怎样正确做 Web 应用的压力测试？](https://www.zhihu.com/question/19867883/answer/2909237820)

[感觉测试用例好难写怎么办?](https://www.zhihu.com/question/393584042/answer/2957750770)

[哪里有 Jmeter 性能测试教程？](https://www.zhihu.com/question/55872938/answer/3092158026)

### 七、职场提升类

[做了大半年的软件测试，可是觉得我在浪费时间，怎么办？](https://www.zhihu.com/question/49654884/answer/1452761382)

[四年测试工程师经历，下一步转开发还是继续测试？](https://www.zhihu.com/question/277034536/answer/1511483058)

[软件测试工程师应该怎样提高自己？](https://www.zhihu.com/question/26644707/answer/1534133907)

[转行软件测试两个多月，感觉很迷茫，下一步该如何提高自己？](https://www.zhihu.com/question/36296780/answer/1583228231)

[四年手动软件测试，裸辞后找不到工作怎么办？](https://www.zhihu.com/question/56831599/answer/1520268900)

[做软件测试，如何才能实现月入 20K？](https://www.zhihu.com/question/373819487/answer/1544096283)

[如何学习自动化测试？](https://www.zhihu.com/question/22211535/answer/1579948115)

[一个菜鸟怎样做好功能测试？](https://www.zhihu.com/question/49877910/answer/1597914370)

[作为软件测试人，所在公司部门只有功能手动测试，如何进一步提升自己？](https://www.zhihu.com/question/66716450/answer/1598655029)

[作为一个初级测试，想学接口测试，但是一点头绪都没有。求教大神指点，有没有好的书或者工具推荐？](https://www.zhihu.com/question/49546647/answer/1651734140)

[做了一年的软件功能测试，想转自动化测试。目前在看了一些 Python 资料，感觉无从下手，求指导？](https://www.zhihu.com/question/51371281/answer/1677887754)

[手工测试人员如何转测试开发？](https://www.zhihu.com/question/61162236/answer/1614932376)

[已从事软件测试一年，感觉依然很菜，只会基础的功能测试，想进一步学习，有没有好的建议呢](https://www.zhihu.com/question/374651679/answer/1904700673)

[想要成为一个性能测试工程师需要掌握哪些知识？](https://www.zhihu.com/question/34227120/answer/2380071628)

[如何从零开始搭建公司自动化测试框架？](https://www.zhihu.com/question/56625870/answer/2429570734)

[新人如何学习性能测试?](https://www.zhihu.com/question/22229787/answer/2479020711)

[如何规范小开发公司的测试流程?](https://www.zhihu.com/question/33406353/answer/2491291115)

[成为一个优秀的测试工程师需要具备哪些知识和经验？](https://www.zhihu.com/question/39085335/answer/2558443624)

[App 的回归测试，有什么高效的测试方法?](https://www.zhihu.com/question/21535114/answer/2577118822)

[有什么好的开源自动化测试框架可以推荐？](https://www.zhihu.com/question/19923336/answer/2585952461)

[26 岁，几乎零基础，想从基础学习渗透测试该如何进行？](https://www.zhihu.com/question/28566200/answer/2739559535)

[有哪些好用的 App 云测试平台？](https://www.zhihu.com/question/48161549/answer/2945231519)

[软件测试工程师如何从功能测试转成自动化测试？](https://www.zhihu.com/question/27986014/answer/3054662174)

[做测试，写了一周的测试 用例，感觉自己已经是个文员了, 怎么办？](https://www.zhihu.com/question/56946964/answer/3055502139)

[自动化测试的成本高效果差，那么自动化测试的意义在哪呢？](https://www.zhihu.com/question/19786019/answer/3222101868)

![](https://picx.zhimg.com/03b42d62450ffcb05428b958512bea22_l.jpg?source=1def8aca)ge gang

这个问题实质就是[投入产出](https://www.zhihu.com/search?q=%E6%8A%95%E5%85%A5%E4%BA%A7%E5%87%BA&search_source=Entity&hybrid_search_source=Entity&hybrid_search_extra=%7B%22sourceType%22%3A%22answer%22%2C%22sourceId%22%3A45048929%7D)问题，是设计问题。

单元测试大小公司大小项目都在尝试采用，而且也不乏成功的例子，QT 项目连界面都使用了单元测试。

但是初期实施非常艰难，我以前的项目坚持了一段时间后来除了我之外，没人编写单元测试，如果要求的话，也仅仅是后期补上单元测试。

现在除了千行以内的原型项目外，所有产品级的项目我都推荐添加单元测试。界面单元测试部分视情况添加，因为大多数桌面系统项目跟 QT 项目有着本质的区别，它是提供用户一致性的窗体组件，而[客户端](https://www.zhihu.com/search?q=%E5%AE%A2%E6%88%B7%E7%AB%AF&search_source=Entity&hybrid_search_source=Entity&hybrid_search_extra=%7B%22sourceType%22%3A%22answer%22%2C%22sourceId%22%3A45048929%7D)系统提供客户千差万别的操作需求，这[需求变动](https://www.zhihu.com/search?q=%E9%9C%80%E6%B1%82%E5%8F%98%E5%8A%A8&search_source=Entity&hybrid_search_source=Entity&hybrid_search_extra=%7B%22sourceType%22%3A%22answer%22%2C%22sourceId%22%3A45048929%7D)还非常快，基本上投入高产出低。

[单元测试](https://www.zhihu.com/search?q=%E5%8D%95%E5%85%83%E6%B5%8B%E8%AF%95&search_source=Entity&hybrid_search_source=Entity&hybrid_search_extra=%7B%22sourceType%22%3A%22answer%22%2C%22sourceId%22%3A45048929%7D)对框架的设计要求非常高，数据与代码与界面要尽可能分离，接口定义，输出与输出预期，代码覆盖度，基本上跟[白盒测试](https://www.zhihu.com/search?q=%E7%99%BD%E7%9B%92%E6%B5%8B%E8%AF%95&search_source=Entity&hybrid_search_source=Entity&hybrid_search_extra=%7B%22sourceType%22%3A%22answer%22%2C%22sourceId%22%3A45048929%7D)差不多的意思。

最后不得不说的是[多线程](https://www.zhihu.com/search?q=%E5%A4%9A%E7%BA%BF%E7%A8%8B&search_source=Entity&hybrid_search_source=Entity&hybrid_search_extra=%7B%22sourceType%22%3A%22answer%22%2C%22sourceId%22%3A45048929%7D)的单元测试，这块我的意见是打 log，分析 log，单元测试基本上不靠谱，也可能是我没有找到合适的方法。

最后采用哪个[测试工具](https://www.zhihu.com/search?q=%E6%B5%8B%E8%AF%95%E5%B7%A5%E5%85%B7&search_source=Entity&hybrid_search_source=Entity&hybrid_search_extra=%7B%22sourceType%22%3A%22answer%22%2C%22sourceId%22%3A45048929%7D)，其实微软测试框架、gtest、qt 测试框架基本上都差不多，无非是测试方向，平台，测试 assert 的[表达能力](https://www.zhihu.com/search?q=%E8%A1%A8%E8%BE%BE%E8%83%BD%E5%8A%9B&search_source=Entity&hybrid_search_source=Entity&hybrid_search_extra=%7B%22sourceType%22%3A%22answer%22%2C%22sourceId%22%3A45048929%7D)。我在 windows 下编码较多，而且使用 [visual studio](https://www.zhihu.com/search?q=visual%20studio&search_source=Entity&hybrid_search_source=Entity&hybrid_search_extra=%7B%22sourceType%22%3A%22answer%22%2C%22sourceId%22%3A45048929%7D)，我使用微软的测试框架，能够可视化的看到代码覆盖情况。

最后的最后，使用了单元测试，你就很容易的使用[持续集成](https://www.zhihu.com/search?q=%E6%8C%81%E7%BB%AD%E9%9B%86%E6%88%90&search_source=Entity&hybrid_search_source=Entity&hybrid_search_extra=%7B%22sourceType%22%3A%22answer%22%2C%22sourceId%22%3A45048929%7D)这种神器。

可以看下 CDash 对持续集成的支持

[CDash - Continuous Integration Made Easy](https://link.zhihu.com/?target=https%3A//open.cdash.org/index.php)

Qt 的持续集成

[Qt Metrics](https://link.zhihu.com/?target=http%3A//testresults.qt.io/qtmetrics/metricspageci.php)  

以前名字叫 hudson 的持续集成工具

[Home - Jenkins](https://link.zhihu.com/?target=https%3A//wiki.jenkins-ci.org/display/JENKINS/Home) ![](https://pic1.zhimg.com/v2-6ee0b5512cae7e920ea89fa0c3e96923_l.jpg?source=1def8aca) 万俊峰 Kevin![](https://picx.zhimg.com/v2-2ee412504af2750d632056929aaf8809_r.jpg?source=1def8aca)

> 特别说明：这个真的不是标题党，我写代码 20 + 年，真心认为 `go fuzzing` 是我见过的最牛逼的代码自测方法。我在用 `AC自动机` 算法改进关键字过滤效率（提升~ 50%），改进 `mapreduce` 对 `panic` 的处理机制的时候，都通过 `go fuzzing` 发现了边缘情况的 bug。所以深深的认为，这是我见过最牛逼的代码自测方法，没有之一！  
> `go fuzzing` 至今已经发现了代码质量极高的 `Go` [标准库](https://www.zhihu.com/search?q=%E6%A0%87%E5%87%86%E5%BA%93&search_source=Entity&hybrid_search_source=Entity&hybrid_search_extra=%7B%22sourceType%22%3A%22answer%22%2C%22sourceId%22%3A2367183792%7D)超过 200 个 bug，见：**[https://github.com/dvyukov/go-fuzz#trophies](https://link.zhihu.com/?target=https%3A//github.com/dvyukov/go-fuzz%23trophies)**

春节程序员之间的祝福经常是，祝你代码永无 bug！虽然调侃，但对我们每个程序员来说，每天都在写 bug，这是事实。代码没 bug 这事，只能证伪，不能证明。即将发布的 Go 1.18 官方提供了一个帮助我们证伪的绝佳工具 - `go fuzzing`。

Go 1.18 大家最关注的是泛型，然而我真的觉得 `go fuzzing` 真的是 Go 1.18 最有用的功能，没有之一！

本文我们就来详细看看 `go fuzzing：`

*   是什么？
*   怎么用？
*   有何最佳实践？

> 首先，你需要升级到 Go 1.18  
> Go 1.18 虽然还未正式发布，但你可以下载 RC 版本，而且即使你生产用 Go 更早版本，你也可以开发环境使用 go fuzzing 寻找 bug

**go fuzzing 是什么**
------------------

根据 **[官方文档](https://link.zhihu.com/?target=https%3A//go.dev/doc/fuzz/)** 介绍，`go fuzzing` 是通过持续给一个程序不同的输入来[自动化测试](https://www.zhihu.com/search?q=%E8%87%AA%E5%8A%A8%E5%8C%96%E6%B5%8B%E8%AF%95&search_source=Entity&hybrid_search_source=Entity&hybrid_search_extra=%7B%22sourceType%22%3A%22answer%22%2C%22sourceId%22%3A2367183792%7D)，并通过分析代码覆盖率来智能的寻找失败的 case。这种方法可以尽可能的寻找到一些边缘 case，亲测确实发现的都是些平时很难发现的问题。

![](https://picx.zhimg.com/v2-13bf646f3a80665ac4a9a48668e25d1a_r.jpg?source=1def8aca)

**go fuzzing 怎么用**
------------------

官方介绍写 fuzz tests 的一些规则：

*   函数必须是 Fuzz 开头，唯一的参数是 `*testing.F`，没有返回值
*   Fuzz tests 必须在 `*_test.go` 的文件里
*   上图中的 `fuzz target` 是个方法调用 `(*testing.F).Fuzz`，第一个参数是 `*testing.T`，然后就是称之为 `fuzzing arguments` 的参数，没有返回值
*   每个 `[fuzz test](https://www.zhihu.com/search?q=fuzz%20test&search_source=Entity&hybrid_search_source=Entity&hybrid_search_extra=%7B%22sourceType%22%3A%22answer%22%2C%22sourceId%22%3A2367183792%7D)` 里只能有一个 `fuzz target`
*   调用 `f.Add(…)` 的时候需要参数类型跟 `fuzzing arguments` 顺序和类型都一致
*   `fuzzing arguments` 只支持以下类型：

*   `string`, `[]byte`
*   `int`, `int8`, `int16`, `int32`/`rune`, `int64`
*   `[uint](https://www.zhihu.com/search?q=uint&search_source=Entity&hybrid_search_source=Entity&hybrid_search_extra=%7B%22sourceType%22%3A%22answer%22%2C%22sourceId%22%3A2367183792%7D)`, `uint8`/`byte`, `uint16`, `uint32`, `uint64`
*   `float32`, `float64`
*   `bool`

*   `fuzz target` 不要依赖全局状态，会并行跑。

### **运行 `fuzzing tests`**

如果我写了一个 `fuzzing test`，比如：

```
// 具体代码见 https://github.com/zeromicro/go-zero/blob/master/core/mr/mapreduce_fuzz_test.go
func FuzzMapReduce(f *testing.F) {
  ...
}


```

那么我们可以这样执行：

```
go test -fuzz=MapReduce

```

我们会得到类似如下结果：

```
fuzz: elapsed: 0s, gathering baseline coverage: 0/2 completed
fuzz: elapsed: 0s, gathering baseline coverage: 2/2 completed, now fuzzing with 10 workers
fuzz: elapsed: 3s, execs: 3338 (1112/sec), new interesting: 56 (total: 57)
fuzz: elapsed: 6s, execs: 6770 (1144/sec), new interesting: 62 (total: 63)
fuzz: elapsed: 9s, execs: 10157 (1129/sec), new interesting: 69 (total: 70)
fuzz: elapsed: 12s, execs: 13586 (1143/sec), new interesting: 72 (total: 73)
^Cfuzz: elapsed: 13s, execs: 14031 (1084/sec), new interesting: 72 (total: 73)
PASS
ok    github.com/zeromicro/go-zero/core/mr  13.169s

```

其中的 `^C` 是我按了 `ctrl-C` 终止了测试，详细解释参考官方文档。

**go-zero 的最佳实践**
-----------------

按照我使用下来的经验总结，我把最佳实践初步总结为以下四步：

1.  定义 `fuzzing arguments`，首先要想明白怎么定义 `fuzzing arguments`，并通过给定的 `fuzzing arguments` 写 `fuzzing target`
2.  思考 `fuzzing target` 怎么写，这里的重点是怎么验证结果的正确性，因为 `fuzzing arguments` 是 “随机” 给的，所以要有个通用的结果验证方法
3.  思考遇到失败的 case 如何打印结果，便于生成新的 `unit test`
4.  根据失败的 `fuzzing test` 打印结果编写新的 `unit test，这个新的` unit test`会被用来调试解决`fuzzing test`发现的问题，并固化下来留给`CI `用`

接下来我们以一个最简单的数组求和[函数](https://www.zhihu.com/search?q=%E5%87%BD%E6%95%B0&search_source=Entity&hybrid_search_source=Entity&hybrid_search_extra=%7B%22sourceType%22%3A%22answer%22%2C%22sourceId%22%3A2367183792%7D)来展示一下上述步骤，go-zero 的实际案例略显复杂，文末我会给出 go-zero 内部落地案例，供大家参考复杂场景写法。

这是一个注入了 bug 的求和的代码实现：

```
func Sum(vals []int64) int64 {
  var total int64

  for _, val := range vals {
    if val%1e5 != 0 {
      total += val
    }
  }

  return total
}


```

### **1. 定义 `[fuzzing arguments](https://www.zhihu.com/search?q=fuzzing%20arguments&search_source=Entity&hybrid_search_source=Entity&hybrid_search_extra=%7B%22sourceType%22%3A%22answer%22%2C%22sourceId%22%3A2367183792%7D)`**

你至少需要给出一个 `fuzzing argument`，不然 `go fuzzing` 没法生成测试代码，所以即使我们没有很好的输入，我们也需要定义一个对结果产生影响的 `fuzzing argument`，这里我们就用 slice 元素个数作为 `fuzzing arguments`，然后 `Go fuzzing` 会根据跑出来的 `code coverage` 自动生成不同的参数来[模拟测试](https://www.zhihu.com/search?q=%E6%A8%A1%E6%8B%9F%E6%B5%8B%E8%AF%95&search_source=Entity&hybrid_search_source=Entity&hybrid_search_extra=%7B%22sourceType%22%3A%22answer%22%2C%22sourceId%22%3A2367183792%7D)。

```
func FuzzSum(f *testing.F) {
  f.Add(10)
  f.Fuzz(func(t *testing.T, n int) {
    n %= 20
    ...
  })
}


```

这里的 `n` 就是让 `go fuzzing` 来模拟 slice 元素个数，为了保证元素个数不会太多，我们限制在 20 以内（0 个也没问题），并且我们添加了一个值为 10 的语料（`go fuzzing` 里面称之为 `corpus`），这个值就是让 `go fuzzing` 冷启动的一个值，具体为多少不重要。

### **2. 怎么写 `[fuzzing target](https://www.zhihu.com/search?q=fuzzing%20target&search_source=Entity&hybrid_search_source=Entity&hybrid_search_extra=%7B%22sourceType%22%3A%22answer%22%2C%22sourceId%22%3A2367183792%7D)`**

这一步的重点是如何编写可验证的 `fuzzing target`，根据给定的 `fuzzing arguments` 写出测试代码的同时，还需要生成验证结果正确性用的数据。

对我们这个 `Sum` 函数来说，其实还是比较简单的，就是随机生成 `n` 个元素的 slice，然后求和算出期望的结果。如下：

```
func FuzzSum(f *testing.F) {
  rand.Seed(time.Now().UnixNano())

  f.Add(10)
  f.Fuzz(func(t *testing.T, n int) {
    n %= 20
    var vals []int64
    var expect int64
    for i := 0; i < n; i++ {
      val := rand.Int63() % 1e6
      vals = append(vals, val)
      expect += val
    }

    assert.Equal(t, expect, Sum(vals))
  })
}


```

这段代码还是很容易理解的，自己求和和 `Sum` 求和做比较而已，就不详细解释了。但复杂场景你就需要仔细想想怎么写验证代码了，不过这不会太难，太难的话，可能是对[测试函数](https://www.zhihu.com/search?q=%E6%B5%8B%E8%AF%95%E5%87%BD%E6%95%B0&search_source=Entity&hybrid_search_source=Entity&hybrid_search_extra=%7B%22sourceType%22%3A%22answer%22%2C%22sourceId%22%3A2367183792%7D)没有足够理解或者简化。

此时就可以用如下命令跑 `[fuzzing tests](https://www.zhihu.com/search?q=fuzzing%20tests&search_source=Entity&hybrid_search_source=Entity&hybrid_search_extra=%7B%22sourceType%22%3A%22answer%22%2C%22sourceId%22%3A2367183792%7D)` 了，结果类似如下：

```
$ go test -fuzz=Sum
fuzz: elapsed: 0s, gathering baseline coverage: 0/2 completed
fuzz: elapsed: 0s, gathering baseline coverage: 2/2 completed, now fuzzing with 10 workers
fuzz: elapsed: 0s, execs: 6672 (33646/sec), new interesting: 7 (total: 6)
--- FAIL: FuzzSum (0.21s)
    --- FAIL: FuzzSum (0.00s)
        sum_fuzz_test.go:34:
              Error Trace:  sum_fuzz_test.go:34
                                  value.go:556
                                  value.go:339
                                  fuzz.go:334
              Error:        Not equal:
                            expected: 8736932
                            actual  : 8636932
              Test:         FuzzSum

    Failing input written to testdata/fuzz/FuzzSum/739002313aceff0ff5ef993030bbde9115541cabee2554e6c9f3faaf581f2004
    To re-run:
    go test -run=FuzzSum/739002313aceff0ff5ef993030bbde9115541cabee2554e6c9f3faaf581f2004
FAIL
exit status 1
FAIL  github.com/kevwan/fuzzing  0.614s

```

那么问题来了！我们看到了结果不对，但是我们很难去分析为啥不对，你仔细品品，上面这段输出，你怎么分析？

### **3. 失败 case 如何打印输入**

对于上面失败的测试，我们如果能打印出输入，然后形成一个简单的[测试用例](https://www.zhihu.com/search?q=%E6%B5%8B%E8%AF%95%E7%94%A8%E4%BE%8B&search_source=Entity&hybrid_search_source=Entity&hybrid_search_extra=%7B%22sourceType%22%3A%22answer%22%2C%22sourceId%22%3A2367183792%7D)，那我们就可以直接调试了。打印出来的输入最好能够直接 `copy/paste` 到新的测试用例里，如果格式不对，对于那么多行的输入，你需要一行一行调格式就太累了，而且这未必就只有一个失败的 case。

所以我们把代码改成了下面这样：

```
func FuzzSum(f *testing.F) {
  rand.Seed(time.Now().UnixNano())

  f.Add(10)
  f.Fuzz(func(t *testing.T, n int) {
    n %= 20
    var vals []int64
    var expect int64
    var buf strings.Builder
    buf.WriteString("\n")
    for i := 0; i < n; i++ {
      val := rand.Int63() % 1e6
      vals = append(vals, val)
      expect += val
      buf.WriteString(fmt.Sprintf("%d,\n", val))
    }

    assert.Equal(t, expect, Sum(vals), buf.String())
  })
}


```

再跑命令，得到如下结果：

```
$ go test -fuzz=Sum
fuzz: elapsed: 0s, gathering baseline coverage: 0/2 completed
fuzz: elapsed: 0s, gathering baseline coverage: 2/2 completed, now fuzzing with 10 workers
fuzz: elapsed: 0s, execs: 1402 (10028/sec), new interesting: 10 (total: 8)
--- FAIL: FuzzSum (0.16s)
    --- FAIL: FuzzSum (0.00s)
        sum_fuzz_test.go:34:
              Error Trace:  sum_fuzz_test.go:34
                                  value.go:556
                                  value.go:339
                                  fuzz.go:334
              Error:        Not equal:
                            expected: 5823336
                            actual  : 5623336
              Test:         FuzzSum
              Messages:
                            799023,
                            110387,
                            811082,
                            115543,
                            859422,
                            997646,
                            200000,
                            399008,
                            7905,
                            931332,
                            591988,

    Failing input written to testdata/fuzz/FuzzSum/26d024acf85aae88f3291bf7e1c6f473eab8b051f2adb1bf05d4491bc49f5767
    To re-run:
    go test -run=FuzzSum/26d024acf85aae88f3291bf7e1c6f473eab8b051f2adb1bf05d4491bc49f5767
FAIL
exit status 1
FAIL  github.com/kevwan/fuzzing  0.602s

```

### **4. 编写新的测试用例**

根据上面的失败 case 的输出，我们可以 `copy/paste` 生成如下代码，当然框架是自己写的，输入参数可以直接拷贝进去。

```
func TestSumFuzzCase1(t *testing.T) {
  vals := []int64{
    799023,
    110387,
    811082,
    115543,
    859422,
    997646,
    200000,
    399008,
    7905,
    931332,
    591988,
  }
  assert.Equal(t, int64(5823336), Sum(vals))
}


```

这样我们就可以很方便的调试了，并且能够增加一个有效 `unit test`，确保这个 bug 再也不会出现了。

**`go fuzzing` 更多经验**
---------------------

### **Go 版本问题**

我相信，Go 1.18 发布了，大多数项目线上代码不会立马升级到 1.18 的，那么 `go fuzzing` 引入的 `testing.F` 不能使用怎么办？

线上（go.mod）不升级到 Go 1.18，但是我们本机是完全推荐升级的，那么这时我们只需要把上面的 `FuzzSum` 放到一个文件名类似 `sum_[fuzz_test.go](https://www.zhihu.com/search?q=fuzz_test.go&search_source=Entity&hybrid_search_source=Entity&hybrid_search_extra=%7B%22sourceType%22%3A%22answer%22%2C%22sourceId%22%3A2367183792%7D)` 的文件里，然后在文件头加上如下指令即可：

```
//go:build go1.18
// +build go1.18


```

> 注意：第三行必须是一个空行，否则就会变成 `package` 的注释了。

这样我们在线上不管用哪个版本就不会报错了，而我们跑 `fuzz testing` 一般都是本机跑的，不受影响。

### **go fuzzing 不能复现的失败**

上面讲的步骤是针对简单情况的，但有时根据失败 case 得到的输入形成新的 `unit test` 并不能复现问题时（特别是有 goroutine 死锁问题），问题就变得复杂起来了，如下输出你感受一下：

```
go test -fuzz=MapReduce
fuzz: elapsed: 0s, gathering baseline coverage: 0/2 completed
fuzz: elapsed: 0s, gathering baseline coverage: 2/2 completed, now fuzzing with 10 workers
fuzz: elapsed: 3s, execs: 3681 (1227/sec), new interesting: 54 (total: 55)
...
fuzz: elapsed: 1m21s, execs: 92705 (1101/sec), new interesting: 85 (total: 86)
--- FAIL: FuzzMapReduce (80.96s)
    fuzzing process hung or terminated unexpectedly: exit status 2
    Failing input written to testdata/fuzz/FuzzMapReduce/ee6a61e8c968adad2e629fba11984532cac5d177c4899d3e0b7c2949a0a3d840
    To re-run:
    go test -run=FuzzMapReduce/ee6a61e8c968adad2e629fba11984532cac5d177c4899d3e0b7c2949a0a3d840
FAIL
exit status 1
FAIL  github.com/zeromicro/go-zero/core/mr  81.471s

```

这种情况下，只是告诉我们 `[fuzzing process](https://www.zhihu.com/search?q=fuzzing%20process&search_source=Entity&hybrid_search_source=Entity&hybrid_search_extra=%7B%22sourceType%22%3A%22answer%22%2C%22sourceId%22%3A2367183792%7D)` 卡住了或者不正常结束了，状态码是 2。这种情况下，一般 `re-run` 是不会复现的。为什么只是简单的返回[错误码 2](https://www.zhihu.com/search?q=%E9%94%99%E8%AF%AF%E7%A0%812&search_source=Entity&hybrid_search_source=Entity&hybrid_search_extra=%7B%22sourceType%22%3A%22answer%22%2C%22sourceId%22%3A2367183792%7D) 呢？我仔细去看了 `go fuzzing` 的源码，每个 `fuzzing test` 都是一个单独的进程跑的，然后 `go fuzzing` 把[模糊测试](https://www.zhihu.com/search?q=%E6%A8%A1%E7%B3%8A%E6%B5%8B%E8%AF%95&search_source=Entity&hybrid_search_source=Entity&hybrid_search_extra=%7B%22sourceType%22%3A%22answer%22%2C%22sourceId%22%3A2367183792%7D)的进程输出扔掉了，只是显示了状态码。那么我们如何解决这个问题呢？

我仔细分析了之后，决定自己来写一个类似 `fuzzing test` 的常规[单元测试](https://www.zhihu.com/search?q=%E5%8D%95%E5%85%83%E6%B5%8B%E8%AF%95&search_source=Entity&hybrid_search_source=Entity&hybrid_search_extra=%7B%22sourceType%22%3A%22answer%22%2C%22sourceId%22%3A2367183792%7D)代码，这样就可以保证失败是在同一个进程内，并且会把错误信息打印到标准输出，代码大致如下：

```
func TestSumFuzzRandom(t *testing.T) {
  const times = 100000
  rand.Seed(time.Now().UnixNano())

  for i := 0; i < times; i++ {
    n := rand.Intn(20)
    var vals []int64
    var expect int64
    var buf strings.Builder
    buf.WriteString("\n")
    for i := 0; i < n; i++ {
      val := rand.Int63() % 1e6
      vals = append(vals, val)
      expect += val
      buf.WriteString(fmt.Sprintf("%d,\n", val))
    }

    assert.Equal(t, expect, Sum(vals), buf.String())
  }
}


```

这样我们就可以自己来简单模拟一下 `go fuzzing`，但是任何错误我们可以得到清晰的输出。这里或许我没研究透 `[go fuzzing](https://www.zhihu.com/search?q=go%20fuzzing&search_source=Entity&hybrid_search_source=Entity&hybrid_search_extra=%7B%22sourceType%22%3A%22answer%22%2C%22sourceId%22%3A2367183792%7D)`，或者还有其它方法可以控制，如果你知道，感谢告诉我一声。

但这种需要跑很长时间的模拟 case，我们不会希望它在 CI 时每次都被执行，所以我把它放在一个单独的文件里，文件名类似 `sum_fuzzcase_test.go`，并在文件头加上了如下指令：

```
//go:build fuzz
// +build fuzz


```

这样我们需要跑这个模拟 case 的时候加上 `-tags fuzz` 即可，比如：

```
go test -tags fuzz ./...

```

**复杂用法示例**
----------

上面介绍的是一个示例，还是比较简单的，如果遇到复杂场景不知道怎么写，可以先看看 go-zero 是如何落地 `go fuzzing` 的，如下所示：

*   MapReduce - [https://github.com/zeromicro/go-zero/tree/master/core/mr](https://link.zhihu.com/?target=https%3A//github.com/zeromicro/go-zero/tree/master/core/mr)

*   模糊测试了 **[死锁](https://www.zhihu.com/search?q=%E6%AD%BB%E9%94%81&search_source=Entity&hybrid_search_source=Entity&hybrid_search_extra=%7B%22sourceType%22%3A%22answer%22%2C%22sourceId%22%3A2367183792%7D)** 和 **goroutine leak**，特别是 `chan + goroutine` 的复杂场景可以借鉴

*   stringx - [https://github.com/zeromicro/go-zero/tree/master/core/stringx](https://link.zhihu.com/?target=https%3A//github.com/zeromicro/go-zero/tree/master/core/stringx)

*   模糊测试了常规的算法实现，对于算法类场景可以借鉴

**项目地址**
--------

**[https://github.com/zeromicro/go-zero](https://link.zhihu.com/?target=https%3A//github.com/zeromicro/go-zero)**

欢迎使用 `go-zero` 并 **star** 支持我们！

**微信交流群**
---------

关注『**[微服务实践](https://www.zhihu.com/search?q=%E5%BE%AE%E6%9C%8D%E5%8A%A1%E5%AE%9E%E8%B7%B5&search_source=Entity&hybrid_search_source=Entity&hybrid_search_extra=%7B%22sourceType%22%3A%22answer%22%2C%22sourceId%22%3A2367183792%7D)**』公众号并点击 **交流群** 获取社区群二维码。