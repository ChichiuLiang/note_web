> 本文由 [简悦 SimpRead](http://ksria.com/simpread/) 转码， 原文地址 [mp.weixin.qq.com](https://mp.weixin.qq.com/s/UjXOchuhqvQ7MfhdY2CyGg)

> 👉 **这是一个或许对你有用****的社群**
> 
> 🐱 一对一交流 / 面试小册 / 简历优化 / 求职解惑，欢迎加入「[**芋道快速开发平台**](http://mp.weixin.qq.com/s?__biz=MzUzMTA2NTU2Ng==&mid=2247576728&idx=1&sn=1298645b025eb51d9078e8c3de7b3c17&chksm=fa4bd329cd3c5a3fd63e455cf39507d3611a7b040be1381fd5ecfc0a7ce3867575fda4b7313d&scene=21#wechat_redirect)」知识星球。下面是星球提供的部分资料： 
> 
> *   [《项目实战（视频）》](http://mp.weixin.qq.com/s?__biz=MzUzMTA2NTU2Ng==&mid=2247576728&idx=1&sn=1298645b025eb51d9078e8c3de7b3c17&chksm=fa4bd329cd3c5a3fd63e455cf39507d3611a7b040be1381fd5ecfc0a7ce3867575fda4b7313d&scene=21#wechat_redirect)：从书中学，往事上 **“练”**
>     
> *   [《互联网高频面试题》](http://mp.weixin.qq.com/s?__biz=MzUzMTA2NTU2Ng==&mid=2247576728&idx=1&sn=1298645b025eb51d9078e8c3de7b3c17&chksm=fa4bd329cd3c5a3fd63e455cf39507d3611a7b040be1381fd5ecfc0a7ce3867575fda4b7313d&scene=21#wechat_redirect)：面朝简历学习，春暖花开
>     
> *   [《架构 x 系统设计》](http://mp.weixin.qq.com/s?__biz=MzUzMTA2NTU2Ng==&mid=2247576728&idx=1&sn=1298645b025eb51d9078e8c3de7b3c17&chksm=fa4bd329cd3c5a3fd63e455cf39507d3611a7b040be1381fd5ecfc0a7ce3867575fda4b7313d&scene=21#wechat_redirect)：摧枯拉朽，掌控面试高频场景题
>     
> *   [《精进 Java 学习指南》](http://mp.weixin.qq.com/s?__biz=MzUzMTA2NTU2Ng==&mid=2247576728&idx=1&sn=1298645b025eb51d9078e8c3de7b3c17&chksm=fa4bd329cd3c5a3fd63e455cf39507d3611a7b040be1381fd5ecfc0a7ce3867575fda4b7313d&scene=21#wechat_redirect)：系统学习，互联网主流技术栈
>     
> *   [《必读 Java 源码专栏》](http://mp.weixin.qq.com/s?__biz=MzUzMTA2NTU2Ng==&mid=2247576728&idx=1&sn=1298645b025eb51d9078e8c3de7b3c17&chksm=fa4bd329cd3c5a3fd63e455cf39507d3611a7b040be1381fd5ecfc0a7ce3867575fda4b7313d&scene=21#wechat_redirect)：知其然，知其所以然
>     

![](https://mmbiz.qpic.cn/mmbiz_gif/JdLkEI9sZfdWPYr0VKaXztEGHacpRyle7tbZkryrsxIpnAfjRt03ibrcloEZqlRPaVKcb0nD2PrYjtovwOAaFlA/640?wx_fmt=gif)

> 👉**这是一个或许对你有用的开源项目**
> 
> 国产 Star 破 10w+ 的开源项目，前端包括管理后台 + 微信小程序，后端支持单体和微服务架构。
> 
> 功能涵盖 RBAC 权限、SaaS 多租户、数据权限、商城、支付、工作流、大屏报表、微信公众号、CRM 等等功能：
> 
> *   Boot 仓库：https://gitee.com/zhijiantianya/ruoyi-vue-pro
>     
> *   Cloud 仓库：https://gitee.com/zhijiantianya/yudao-cloud
>     
> *   视频教程：https://doc.iocoder.cn
>     
> 
> 【国内首批】支持 JDK 21 + SpringBoot 3.2.0、JDK 8 + Spring Boot 2.7.18 双版本 

[来源：blog.csdn.net/buertianci/](https://mp.weixin.qq.com/s?__biz=MzUzMTA2NTU2Ng==&mid=2247487551&idx=1&sn=18f64ba49f3f0f9d8be9d1fdef8857d9&scene=21#wechat_redirect)

[article/details/105327031](https://mp.weixin.qq.com/s?__biz=MzUzMTA2NTU2Ng==&mid=2247487551&idx=1&sn=18f64ba49f3f0f9d8be9d1fdef8857d9&scene=21#wechat_redirect)

*   [01、背景](https://mp.weixin.qq.com/s?__biz=MzUzMTA2NTU2Ng==&mid=2247487551&idx=1&sn=18f64ba49f3f0f9d8be9d1fdef8857d9&chksm=fa496f8ecd3ee698f4954c00efb80fe955ec9198fff3ef4011e331aa37f55a6a17bc8c0335a8&scene=21&token=899450012&lang=zh_CN#wechat_redirect)
    
*   [02、Disruptor 介绍](https://mp.weixin.qq.com/s?__biz=MzUzMTA2NTU2Ng==&mid=2247487551&idx=1&sn=18f64ba49f3f0f9d8be9d1fdef8857d9&chksm=fa496f8ecd3ee698f4954c00efb80fe955ec9198fff3ef4011e331aa37f55a6a17bc8c0335a8&scene=21&token=899450012&lang=zh_CN#wechat_redirect)
    
*   [03、Disruptor 的核心概念](https://mp.weixin.qq.com/s?__biz=MzUzMTA2NTU2Ng==&mid=2247487551&idx=1&sn=18f64ba49f3f0f9d8be9d1fdef8857d9&chksm=fa496f8ecd3ee698f4954c00efb80fe955ec9198fff3ef4011e331aa37f55a6a17bc8c0335a8&scene=21&token=899450012&lang=zh_CN#wechat_redirect)
    
*   [04、Ring Buffer](https://mp.weixin.qq.com/s?__biz=MzUzMTA2NTU2Ng==&mid=2247487551&idx=1&sn=18f64ba49f3f0f9d8be9d1fdef8857d9&chksm=fa496f8ecd3ee698f4954c00efb80fe955ec9198fff3ef4011e331aa37f55a6a17bc8c0335a8&scene=21&token=899450012&lang=zh_CN#wechat_redirect)
    
*   [05、Sequence Disruptor](https://mp.weixin.qq.com/s?__biz=MzUzMTA2NTU2Ng==&mid=2247487551&idx=1&sn=18f64ba49f3f0f9d8be9d1fdef8857d9&chksm=fa496f8ecd3ee698f4954c00efb80fe955ec9198fff3ef4011e331aa37f55a6a17bc8c0335a8&scene=21&token=899450012&lang=zh_CN#wechat_redirect)
    
*   [06、Sequencer](https://mp.weixin.qq.com/s?__biz=MzUzMTA2NTU2Ng==&mid=2247487551&idx=1&sn=18f64ba49f3f0f9d8be9d1fdef8857d9&chksm=fa496f8ecd3ee698f4954c00efb80fe955ec9198fff3ef4011e331aa37f55a6a17bc8c0335a8&scene=21&token=899450012&lang=zh_CN#wechat_redirect)
    
*   [07、Sequence Barrier](https://mp.weixin.qq.com/s?__biz=MzUzMTA2NTU2Ng==&mid=2247487551&idx=1&sn=18f64ba49f3f0f9d8be9d1fdef8857d9&chksm=fa496f8ecd3ee698f4954c00efb80fe955ec9198fff3ef4011e331aa37f55a6a17bc8c0335a8&scene=21&token=899450012&lang=zh_CN#wechat_redirect)
    
*   [08、Wait Strategy](https://mp.weixin.qq.com/s?__biz=MzUzMTA2NTU2Ng==&mid=2247487551&idx=1&sn=18f64ba49f3f0f9d8be9d1fdef8857d9&chksm=fa496f8ecd3ee698f4954c00efb80fe955ec9198fff3ef4011e331aa37f55a6a17bc8c0335a8&scene=21&token=899450012&lang=zh_CN#wechat_redirect)
    
*   [09、Event](https://mp.weixin.qq.com/s?__biz=MzUzMTA2NTU2Ng==&mid=2247487551&idx=1&sn=18f64ba49f3f0f9d8be9d1fdef8857d9&chksm=fa496f8ecd3ee698f4954c00efb80fe955ec9198fff3ef4011e331aa37f55a6a17bc8c0335a8&scene=21&token=899450012&lang=zh_CN#wechat_redirect)
    
*   [10、EventProcessor](https://mp.weixin.qq.com/s?__biz=MzUzMTA2NTU2Ng==&mid=2247487551&idx=1&sn=18f64ba49f3f0f9d8be9d1fdef8857d9&chksm=fa496f8ecd3ee698f4954c00efb80fe955ec9198fff3ef4011e331aa37f55a6a17bc8c0335a8&scene=21&token=899450012&lang=zh_CN#wechat_redirect)
    
*   [11、EventHandler](https://mp.weixin.qq.com/s?__biz=MzUzMTA2NTU2Ng==&mid=2247487551&idx=1&sn=18f64ba49f3f0f9d8be9d1fdef8857d9&chksm=fa496f8ecd3ee698f4954c00efb80fe955ec9198fff3ef4011e331aa37f55a6a17bc8c0335a8&scene=21&token=899450012&lang=zh_CN#wechat_redirect)
    
*   [12、Producer](https://mp.weixin.qq.com/s?__biz=MzUzMTA2NTU2Ng==&mid=2247487551&idx=1&sn=18f64ba49f3f0f9d8be9d1fdef8857d9&chksm=fa496f8ecd3ee698f4954c00efb80fe955ec9198fff3ef4011e331aa37f55a6a17bc8c0335a8&scene=21&token=899450012&lang=zh_CN#wechat_redirect)
    
*   [13、案例 - demo](https://mp.weixin.qq.com/s?__biz=MzUzMTA2NTU2Ng==&mid=2247487551&idx=1&sn=18f64ba49f3f0f9d8be9d1fdef8857d9&chksm=fa496f8ecd3ee698f4954c00efb80fe955ec9198fff3ef4011e331aa37f55a6a17bc8c0335a8&scene=21&token=899450012&lang=zh_CN#wechat_redirect)
    
*   [14、总结](https://mp.weixin.qq.com/s?__biz=MzUzMTA2NTU2Ng==&mid=2247487551&idx=1&sn=18f64ba49f3f0f9d8be9d1fdef8857d9&chksm=fa496f8ecd3ee698f4954c00efb80fe955ec9198fff3ef4011e331aa37f55a6a17bc8c0335a8&scene=21&token=899450012&lang=zh_CN#wechat_redirect)
    

[![](https://mmbiz.qpic.cn/mmbiz_jpg/TNUwKhV0JpQUG0CKCjmzpSfdVibibuAmFS0DV6aduQzAa1TEibBfYylNJiaLNEibDMeiaG9QK2bUYsGDiaTicuMEjxNichQ/640?wx_fmt=jpeg&wxfrom=5&wx_lazy=1&wx_co=1)](https://mp.weixin.qq.com/s?__biz=MzUzMTA2NTU2Ng==&mid=2247487551&idx=1&sn=18f64ba49f3f0f9d8be9d1fdef8857d9&chksm=fa496f8ecd3ee698f4954c00efb80fe955ec9198fff3ef4011e331aa37f55a6a17bc8c0335a8&scene=21&token=899450012&lang=zh_CN#wechat_redirect)

* * *

[01、背景](https://mp.weixin.qq.com/s?__biz=MzUzMTA2NTU2Ng==&mid=2247487551&idx=1&sn=18f64ba49f3f0f9d8be9d1fdef8857d9&scene=21#wechat_redirect)
--------------------------------------------------------------------------------------------------------------------------------------------

工作中遇到项目使用 Disruptor 做消息队列, 对你没看错, 不是 Kafka, 也不是 rabbitmq;Disruptor 有个最大的优点就是快, 还有一点它是开源的哦, 下面做个简单的记录.

> 基于 Spring Boot + MyBatis Plus + Vue & Element 实现的后台管理系统 + 用户小程序，支持 RBAC 动态权限、多租户、数据权限、工作流、三方登录、支付、短信、商城等功能
> 
> *   项目地址：https://github.com/YunaiV/ruoyi-vue-pro
>     
> *   视频教程：https://doc.iocoder.cn/video/
>     

[02、Disruptor 介绍](https://mp.weixin.qq.com/s?__biz=MzUzMTA2NTU2Ng==&mid=2247487551&idx=1&sn=18f64ba49f3f0f9d8be9d1fdef8857d9&scene=21#wechat_redirect)
------------------------------------------------------------------------------------------------------------------------------------------------------

1.  Disruptor 是英国外汇交易公司 LMAX 开发的一个高性能队列，研发的初衷是解决内存队列的延迟问题（在性能测试中发现竟然与 I/O 操作处于同样的数量级）。基于 Disruptor 开发的系统单线程能支撑每秒 600 万订单，2010 年在 QCon 演讲后，获得了业界关注。
    
2.  Disruptor 是一个开源的 Java 框架，它被设计用于在生产者—消费者（producer-consumer problem，简称 PCP）问题上获得尽量高的吞吐量（TPS）和尽量低的延迟。
    
3.  从功能上来看，Disruptor 是实现了 “队列” 的功能，而且是一个有界队列。那么它的应用场景自然就是 “生产者 - 消费者” 模型的应用场合了。
    
4.  Disruptor 是 LMAX 在线交易平台的关键组成部分，LMAX 平台使用该框架对订单处理速度能达到 600 万 TPS，除金融领域之外，其他一般的应用中都可以用到 Disruptor，它可以带来显著的性能提升。
    
5.  其实 Disruptor 与其说是一个框架，不如说是一种设计思路，这个设计思路对于存在 “并发、缓冲区、生产者—消费者模型、事务处理” 这些元素的程序来说，Disruptor 提出了一种大幅提升性能（TPS）的方案。
    
6.  Disruptor 的 github 主页：https://github.com/LMAX-Exchange/disruptor
    

> 基于 Spring Cloud Alibaba + Gateway + Nacos + RocketMQ + Vue & Element 实现的后台管理系统 + 用户小程序，支持 RBAC 动态权限、多租户、数据权限、工作流、三方登录、支付、短信、商城等功能
> 
> *   项目地址：https://github.com/YunaiV/yudao-cloud
>     
> *   视频教程：https://doc.iocoder.cn/video/
>     

[03、Disruptor 的核心概念](https://mp.weixin.qq.com/s?__biz=MzUzMTA2NTU2Ng==&mid=2247487551&idx=1&sn=18f64ba49f3f0f9d8be9d1fdef8857d9&scene=21#wechat_redirect)
---------------------------------------------------------------------------------------------------------------------------------------------------------

先从了解 Disruptor 的核心概念开始，来了解它是如何运作的。下面介绍的概念模型，既是领域对象，也是映射到代码实现上的核心对象。

[04、Ring Buffer](https://mp.weixin.qq.com/s?__biz=MzUzMTA2NTU2Ng==&mid=2247487551&idx=1&sn=18f64ba49f3f0f9d8be9d1fdef8857d9&scene=21#wechat_redirect)
-----------------------------------------------------------------------------------------------------------------------------------------------------

如其名，环形的缓冲区。曾经 RingBuffer 是 Disruptor 中的最主要的对象，但从 3.0 版本开始，其职责被简化为仅仅负责对通过 Disruptor 进行交换的数据（事件）进行存储和更新。在一些更高级的应用场景中，Ring Buffer 可以由用户的自定义实现来完全替代。

[05、Sequence Disruptor](https://mp.weixin.qq.com/s?__biz=MzUzMTA2NTU2Ng==&mid=2247487551&idx=1&sn=18f64ba49f3f0f9d8be9d1fdef8857d9&scene=21#wechat_redirect)
------------------------------------------------------------------------------------------------------------------------------------------------------------

通过顺序递增的序号来编号管理通过其进行交换的数据（事件），对数据 (事件) 的处理过程总是沿着序号逐个递增处理。一个 Sequence 用于跟踪标识某个特定的事件处理者 ( RingBuffer/Consumer ) 的处理进度。虽然一个 AtomicLong 也可以用于标识进度，但定义 Sequence 来负责该问题还有另一个目的，那就是防止不同的 Sequence 之间的 CPU 缓存伪共享 (Flase Sharing) 问题。（注：这是 Disruptor 实现高性能的关键点之一，网上关于伪共享问题的介绍已经汗牛充栋，在此不再赘述）。

[06、Sequencer](https://mp.weixin.qq.com/s?__biz=MzUzMTA2NTU2Ng==&mid=2247487551&idx=1&sn=18f64ba49f3f0f9d8be9d1fdef8857d9&scene=21#wechat_redirect)
---------------------------------------------------------------------------------------------------------------------------------------------------

Sequencer 是 Disruptor 的真正核心。此接口有两个实现类 SingleProducerSequencer、MultiProducerSequencer ，它们定义在生产者和消费者之间快速、正确地传递数据的并发算法。

[07、Sequence Barrier](https://mp.weixin.qq.com/s?__biz=MzUzMTA2NTU2Ng==&mid=2247487551&idx=1&sn=18f64ba49f3f0f9d8be9d1fdef8857d9&scene=21#wechat_redirect)
----------------------------------------------------------------------------------------------------------------------------------------------------------

用于保持对 RingBuffer 的 main published Sequence 和 Consumer 依赖的其它 Consumer 的 Sequence 的引用。Sequence Barrier 还定义了决定 Consumer 是否还有可处理的事件的逻辑。

[08、Wait Strategy](https://mp.weixin.qq.com/s?__biz=MzUzMTA2NTU2Ng==&mid=2247487551&idx=1&sn=18f64ba49f3f0f9d8be9d1fdef8857d9&scene=21#wechat_redirect)
-------------------------------------------------------------------------------------------------------------------------------------------------------

定义 Consumer 如何进行等待下一个事件的策略。（注：Disruptor 定义了多种不同的策略，针对不同的场景，提供了不一样的性能表现）

[09、Event](https://mp.weixin.qq.com/s?__biz=MzUzMTA2NTU2Ng==&mid=2247487551&idx=1&sn=18f64ba49f3f0f9d8be9d1fdef8857d9&scene=21#wechat_redirect)
-----------------------------------------------------------------------------------------------------------------------------------------------

在 Disruptor 的语义中，生产者和消费者之间进行交换的数据被称为事件 (Event)。它不是一个被 Disruptor 定义的特定类型，而是由 Disruptor 的使用者定义并指定。

[10、EventProcessor](https://mp.weixin.qq.com/s?__biz=MzUzMTA2NTU2Ng==&mid=2247487551&idx=1&sn=18f64ba49f3f0f9d8be9d1fdef8857d9&scene=21#wechat_redirect)
--------------------------------------------------------------------------------------------------------------------------------------------------------

EventProcessor 持有特定消费者 (Consumer) 的 Sequence，并提供用于调用事件处理实现的事件循环(Event Loop)。

[11、EventHandler](https://mp.weixin.qq.com/s?__biz=MzUzMTA2NTU2Ng==&mid=2247487551&idx=1&sn=18f64ba49f3f0f9d8be9d1fdef8857d9&scene=21#wechat_redirect)
------------------------------------------------------------------------------------------------------------------------------------------------------

Disruptor 定义的事件处理接口，由用户实现，用于处理事件，是 Consumer 的真正实现。

[12、Producer](https://mp.weixin.qq.com/s?__biz=MzUzMTA2NTU2Ng==&mid=2247487551&idx=1&sn=18f64ba49f3f0f9d8be9d1fdef8857d9&scene=21#wechat_redirect)
--------------------------------------------------------------------------------------------------------------------------------------------------

即生产者，只是泛指调用 Disruptor 发布事件的用户代码，Disruptor 没有定义特定接口或类型。

![](https://mmbiz.qpic.cn/mmbiz_png/JdLkEI9sZfeoByeogGJV00GcoZuI1xxPzqqeYBc32SkRiad3lgZJcfF8icUoiaZEQJSztHXsRLA2HmQLkyyldBmKg/640?wx_fmt=png&wxfrom=5&wx_lazy=1&wx_co=1)

[13、案例 - demo](https://mp.weixin.qq.com/s?__biz=MzUzMTA2NTU2Ng==&mid=2247487551&idx=1&sn=18f64ba49f3f0f9d8be9d1fdef8857d9&scene=21#wechat_redirect)
---------------------------------------------------------------------------------------------------------------------------------------------------

*   通过下面 8 个步骤, 你就能将 Disruptor Get 回家啦：
    
*   1、添加 pom.xml 依赖
    

```
<dependency>    <groupId>com.lmax</groupId>    <artifactId>disruptor</artifactId>    <version>3.3.4</version></dependency>
```

*   2、消息体 Model
    

```
/** * 消息体 */@Datapublic class MessageModel {    private String message;}
```

*   3、构造 EventFactory
    

```
public class HelloEventFactory implements EventFactory<MessageModel> {    @Override    public MessageModel newInstance() {        return new MessageModel();    }}
```

*   4、构造 EventHandler - 消费者
    

```
@Slf4jpublic class HelloEventHandler implements EventHandler<MessageModel> {    @Override    public void onEvent(MessageModel event, long sequence, boolean endOfBatch) {        try {            //这里停止1000ms是为了确定消费消息是异步的            Thread.sleep(1000);            log.info("消费者处理消息开始");            if (event != null) {                log.info("消费者消费的信息是：{}",event);            }        } catch (Exception e) {            log.info("消费者处理消息失败");        }        log.info("消费者处理消息结束");    }}
```

*   5、构造 BeanManager
    

```
/** * 获取实例化对象 */@Componentpublic class BeanManager implements ApplicationContextAware {    private static ApplicationContext applicationContext = null;    @Override    public void setApplicationContext(ApplicationContext applicationContext) throws BeansException {        this.applicationContext = applicationContext;    }    public static ApplicationContext getApplicationContext() { return applicationContext; }    public static Object getBean(String name) {        return applicationContext.getBean(name);    }    public static <T> T getBean(Class<T> clazz) {        return applicationContext.getBean(clazz);    }}
```

*   6、构造 MQManager
    

```
@Configurationpublic class MQManager {    @Bean("messageModel")    public RingBuffer<MessageModel> messageModelRingBuffer() {        //定义用于事件处理的线程池， Disruptor通过java.util.concurrent.ExecutorSerivce提供的线程来触发consumer的事件处理        ExecutorService executor = Executors.newFixedThreadPool(2);        //指定事件工厂        HelloEventFactory factory = new HelloEventFactory();        //指定ringbuffer字节大小，必须为2的N次方（能将求模运算转为位运算提高效率），否则将影响效率        int bufferSize = 1024 * 256;        //单线程模式，获取额外的性能        Disruptor<MessageModel> disruptor = new Disruptor<>(factory, bufferSize, executor,                ProducerType.SINGLE, new BlockingWaitStrategy());        //设置事件业务处理器---消费者        disruptor.handleEventsWith(new HelloEventHandler());        // 启动disruptor线程        disruptor.start();        //获取ringbuffer环，用于接取生产者生产的事件        RingBuffer<MessageModel> ringBuffer = disruptor.getRingBuffer();        return ringBuffer;    }
```

*   7、构造 Mqservice 和实现类 - 生产者
    

```
public interface DisruptorMqService {    /**     * 消息     * @param message     */    void sayHelloMq(String message);}@Slf4j@Component@Servicepublic class DisruptorMqServiceImpl implements DisruptorMqService {    @Autowired    private RingBuffer<MessageModel> messageModelRingBuffer;    @Override    public void sayHelloMq(String message) {        log.info("record the message: {}",message);        //获取下一个Event槽的下标        long sequence = messageModelRingBuffer.next();        try {            //给Event填充数据            MessageModel event = messageModelRingBuffer.get(sequence);            event.setMessage(message);            log.info("往消息队列中添加消息：{}", event);        } catch (Exception e) {            log.error("failed to add event to messageModelRingBuffer for : e = {},{}",e,e.getMessage());        } finally {            //发布Event，激活观察者去消费，将sequence传递给改消费者            //注意最后的publish方法必须放在finally中以确保必须得到调用；如果某个请求的sequence未被提交将会堵塞后续的发布操作或者其他的producer            messageModelRingBuffer.publish(sequence);        }    }}
```

*   8、构造测试类及方法
    

```
@Slf4j@RunWith(SpringRunner.class)@SpringBootTest(classes = DemoApplication.class)public class DemoApplicationTests {    @Autowired    private DisruptorMqService disruptorMqService;    /**     * 项目内部使用Disruptor做消息队列     * @throws Exception     */    @Test    public void sayHelloMqTest() throws Exception{        disruptorMqService.sayHelloMq("消息到了，Hello world!");        log.info("消息队列已发送完毕");        //这里停止2000ms是为了确定是处理消息是异步的        Thread.sleep(2000);    }}
```

测试运行结果

```
2020-04-05 14:31:18.543  INFO 7274 --- [           main] c.e.u.d.d.s.Impl.DisruptorMqServiceImpl  : record the message: 消息到了，Hello world!2020-04-05 14:31:18.545  INFO 7274 --- [           main] c.e.u.d.d.s.Impl.DisruptorMqServiceImpl  : 往消息队列中添加消息：MessageModel(message=消息到了，Hello world!)2020-04-05 14:31:18.545  INFO 7274 --- [           main] c.e.utils.demo.DemoApplicationTests      : 消息队列已发送完毕2020-04-05 14:31:19.547  INFO 7274 --- [pool-1-thread-1] c.e.u.d.disrupMq.mq.HelloEventHandler    : 消费者处理消息开始2020-04-05 14:31:19.547  INFO 7274 --- [pool-1-thread-1] c.e.u.d.disrupMq.mq.HelloEventHandler    : 消费者消费的信息是：MessageModel(message=消息到了，Hello world!)2020-04-05 14:31:19.547  INFO 7274 --- [pool-1-thread-1] c.e.u.d.disrupMq.mq.HelloEventHandler    : 消费者处理消息结束
```

[14、总结](https://mp.weixin.qq.com/s?__biz=MzUzMTA2NTU2Ng==&mid=2247487551&idx=1&sn=18f64ba49f3f0f9d8be9d1fdef8857d9&scene=21#wechat_redirect)
--------------------------------------------------------------------------------------------------------------------------------------------

其实 生成者 -> 消费者 模式是很常见的，通过一些消息队列也可以轻松做到上述的效果。不同的地方在于，Disruptor 是在内存中以队列的方式去实现的，而且是无锁的。这也是 Disruptor 为什么高效的原因。

* * *

欢迎加入我的知识星球，全面提升技术能力。

👉 加入方式，**“**长按**” 或 “**扫描**” 下方二维码噢**：

![](https://mmbiz.qpic.cn/mmbiz_png/JdLkEI9sZfdvrE36I5uQ6ZlawMiahg3UYUmeiaibJrfebfNR8mDWMzmMXB49BMGYiaK7KnsSjGjP7JJoEGoRxZQMMg/640?wx_fmt=png)

星球的**内容包括**：项目实战、面试招聘、源码解析、学习路线。

![](https://mmbiz.qpic.cn/mmbiz_png/JdLkEI9sZfdWPYr0VKaXztEGHacpRyle64G451XsWx4Ufc9FHYmNTqFdKdtNhyjlhrEC7Pic1dRfue78ib3TiaKBg/640?wx_fmt=png)

![](https://mmbiz.qpic.cn/mmbiz_png/JdLkEI9sZfdWPYr0VKaXztEGHacpRylewlfAU6nBKS8tWSIrLcmSicsq0ECUIVnf0JHibsLARrp4Z3ZCh5oSvYMQ/640?wx_fmt=png)![](https://mmbiz.qpic.cn/mmbiz_png/JdLkEI9sZfdWPYr0VKaXztEGHacpRyleptHSrmBV71SbQSolzZpmdqN2q03yLwk1bwZYNu2lr17gFjO0rh1ZdQ/640?wx_fmt=png)![](https://mmbiz.qpic.cn/mmbiz_png/JdLkEI9sZfdWPYr0VKaXztEGHacpRyleYQLfl6qLTABQx5UrP0dXXv6cSv2TmBoouiciaZIXwyD88h5OIsM8lpkw/640?wx_fmt=png)![](https://mmbiz.qpic.cn/mmbiz_png/JdLkEI9sZfdWPYr0VKaXztEGHacpRyleicAvrkTkdGYRubqZdPNkqpoTmtOCQjkItotwtAbCxibsWUI4Dz0ILTEg/640?wx_fmt=png)

```
文章有帮助的话，在看，转发吧。

谢谢支持哟 (*^__^*）

```